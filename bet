from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support. ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium. common.exceptions import TimeoutException, NoSuchElementException
from selenium.webdriver.common.action_chains import ActionChains
import time
import pickle
import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import threading
from datetime import datetime
import re
import base64
from io import BytesIO

# ================== é…ç½® ==================
URL = "https://mos055.com/"
USERNAME = "LJJ123123"
PASSWORD = "zz66688899"
COOKIES_FILE = "mos055_cookies.pkl"

# ================== BettingBot ç±» ==================
class BettingBot: 
    def __init__(self):
        self.driver = None
        self.is_running = False
        self. is_logged_in = False
        self. wait = None
        self.auto_bet_enabled = False
        self.bet_amount = 2
        self.bet_history = []
        self.threshold_settings = {}
        self.current_matches = []
        self.font_map = {}  # å­—ä½“æ˜ å°„è¡¨
        
    def setup_driver(self, headless=False):
        options = webdriver.ChromeOptions()
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
        options.add_argument("--disable-blink-features=AutomationControlled")
        options.add_argument("--disable-gpu")
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        options.add_argument("--window-size=1920,1080")
        options.add_argument("user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
        
        if headless:
            options.add_argument("--headless=new")
        
        self.driver = webdriver.Chrome(options=options)
        self.wait = WebDriverWait(self. driver, 60)
        
        self.driver.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {
            'source': '''
                Object.defineProperty(navigator, 'webdriver', {get: () => undefined});
                window.chrome = {runtime: {}};
            '''
        })
    
    def handle_password_popup(self, log_callback):
        log_callback("æ£€æµ‹å¹¶å¤„ç†ç®€æ˜“å¯†ç å¼¹çª—...")
        
        for attempt in range(15):
            try:
                popup_visible = self.driver.execute_script("""
                    var popup = document.getElementById('c_alert_modify');
                    if (popup) {
                        var style = window.getComputedStyle(popup);
                        return popup.offsetWidth > 0 && popup.offsetHeight > 0 && 
                               style.display !== 'none' && style.visibility !== 'hidden';
                    }
                    return false;
                """)
                
                if not popup_visible:
                    has_popup_text = self.driver.execute_script("""
                        return document.body.innerText.includes('ç®€æ˜“å¯†ç ') || 
                               document.body.innerText.includes('å¿«é€Ÿç™»å…¥');
                    """)
                    if not has_popup_text:
                        log_callback("âœ“ å¼¹çª—å·²å…³é—­æˆ–ä¸å­˜åœ¨")
                        return True
                
                result = self.driver.execute_script("""
                    var elements = document.querySelectorAll('div, button, span');
                    for (var elem of elements) {
                        if (elem.innerText.trim() === 'å¦' && 
                            elem.offsetWidth > 0 && elem.offsetHeight > 0) {
                            elem.click();
                            return {success: true};
                        }
                    }
                    return {success: false};
                """)
                if result.get('success'):
                    log_callback(f"  ç¬¬{attempt+1}æ¬¡ç‚¹å‡»æˆåŠŸ")
                    time.sleep(2)
                    continue
                
                time.sleep(1)
            except: 
                time.sleep(1)
        
        return False
        
    def login(self, username, password, log_callback):
        try:
            log_callback("æ­£åœ¨è®¿é—®ç™»å½•é¡µé¢...")
            self.driver.get(URL)
            time.sleep(8)
            
            username_field = self.wait.until(EC.element_to_be_clickable((By. ID, "usr")))
            log_callback("âœ“ æ‰¾åˆ°ç”¨æˆ·åè¾“å…¥æ¡†")
            self.driver.execute_script("arguments[0].value = arguments[1];", username_field, username)
            log_callback(f"âœ“ å·²è¾“å…¥ç”¨æˆ·å: {username}")
            
            password_field = self.wait.until(EC. element_to_be_clickable((By.ID, "pwd")))
            self.driver.execute_script("arguments[0].value = arguments[1];", password_field, password)
            log_callback("âœ“ å·²è¾“å…¥å¯†ç ")
            
            login_button = self.wait.until(EC.element_to_be_clickable((By. ID, "btn_login")))
            self.driver.execute_script("arguments[0].click();", login_button)
            log_callback("âœ“ å·²ç‚¹å‡»ç™»å½•æŒ‰é’®")
            
            log_callback("\nç­‰å¾…ç™»å½•å“åº”...")
            time.sleep(10)
            
            self.handle_password_popup(log_callback)
            time.sleep(3)
            
            log_callback("\nç­‰å¾…ä¸»é¡µé¢åŠ è½½...")
            for i in range(12):
                time.sleep(5)
                elapsed = (i + 1) * 5
                log_callback(f"  å·²ç­‰å¾… {elapsed} ç§’...")
                
                if elapsed % 10 == 0:
                    try:
                        found = self.driver.execute_script("""
                            var elements = document.querySelectorAll('*');
                            for (var elem of elements) {
                                var text = (elem.textContent || '').trim();
                                if (text === 'æ»šçƒ' && elem.offsetWidth > 0 && elem.offsetHeight > 0) {
                                    return true;
                                }
                            }
                            return false;
                        """)
                        if found:
                            log_callback(f"âœ“ é¡µé¢å·²åŠ è½½å®Œæˆ")
                            break
                    except:
                        pass
            
            log_callback(f"\nå½“å‰URL: {self.driver.current_url}")
            
            cookies = self.driver.get_cookies()
            with open(COOKIES_FILE, "wb") as f:
                pickle.dump(cookies, f)
            log_callback(f"âœ“ Cookies å·²ä¿å­˜")
            
            log_callback("\nè¿›å…¥æ»šçƒé¡µé¢...")
            time.sleep(3)
            
            click_result = self.driver.execute_script("""
                var elements = document.querySelectorAll('*');
                for (var elem of elements) {
                    var text = (elem.textContent || '').trim();
                    var visible = elem.offsetWidth > 0 && elem.offsetHeight > 0;
                    if (visible && text === 'æ»šçƒ') {
                        elem.scrollIntoView({behavior: 'smooth', block:  'center'});
                        elem.click();
                        return {success: true};
                    }
                }
                return {success: false};
            """)
            
            if click_result.get('success'):
                log_callback(f"âœ“ å·²ç‚¹å‡»æ»šçƒ")
            
            log_callback("ç­‰å¾…æ»šçƒé¡µé¢åŠ è½½...")
            time.sleep(10)
            
            self.is_logged_in = True
            log_callback("\nâœ“ ç™»å½•æµç¨‹å®Œæˆï¼")
            
            return True
            
        except Exception as e:
            log_callback(f"\nâœ— ç™»å½•å¤±è´¥:  {str(e)}")
            return False

    def diagnose_page(self, log_callback):
        """è¯Šæ–­é¡µé¢ï¼Œæ£€æµ‹åçˆ¬è™«æŠ€æœ¯"""
        log_callback("\nğŸ” å¼€å§‹è¯Šæ–­é¡µé¢...")
        
        diagnosis = self.driver.execute_script("""
            function diagnosePage() {
                var result = {
                    customFonts: [],
                    canvasElements: [],
                    svgElements: [],
                    cssContentElements: [],
                    backgroundImages: [],
                    iframes: [],
                    shadowDOMs: [],
                    webglElements: [],
                    suspiciousElements: []
                };
                
                // 1. æ£€æµ‹è‡ªå®šä¹‰å­—ä½“
                var allElements = document.querySelectorAll('*');
                var fontFamilies = new Set();
                
                allElements.forEach(function(elem) {
                    if (elem.offsetWidth > 0 && elem. offsetHeight > 0) {
                        var style = window.getComputedStyle(elem);
                        var fontFamily = style.fontFamily;
                        
                        // æ£€æµ‹å¯ç–‘å­—ä½“
                        if (fontFamily && ! fontFamily.includes('Arial') && 
                            !fontFamily.includes('Helvetica') && 
                            !fontFamily.includes('sans-serif') &&
                            ! fontFamily.includes('Microsoft YaHei')) {
                            fontFamilies.add(fontFamily);
                        }
                        
                        // æ£€æµ‹CSS content
                        var beforeContent = window.getComputedStyle(elem, '::before').content;
                        var afterContent = window.getComputedStyle(elem, '::after').content;
                        
                        if (beforeContent && beforeContent !== 'none' && beforeContent !== 'normal') {
                            result.cssContentElements.push({
                                tag: elem.tagName,
                                class: elem.className,
                                content: beforeContent,
                                type: 'before'
                            });
                        }
                        
                        if (afterContent && afterContent !== 'none' && afterContent !== 'normal') {
                            result.cssContentElements.push({
                                tag: elem.tagName,
                                class: elem.className,
                                content: afterContent,
                                type: 'after'
                            });
                        }
                        
                        // æ£€æµ‹èƒŒæ™¯å›¾ç‰‡
                        var bgImage = style.backgroundImage;
                        if (bgImage && bgImage !== 'none') {
                            result.backgroundImages.push({
                                tag: elem.tagName,
                                class: elem.className,
                                bgImage: bgImage. substring(0, 100)
                            });
                        }
                    }
                });
                
                result.customFonts = Array. from(fontFamilies);
                
                // 2. æ£€æµ‹Canvaså…ƒç´ 
                var canvases = document.querySelectorAll('canvas');
                canvases.forEach(function(canvas) {
                    var rect = canvas.getBoundingClientRect();
                    result.canvasElements.push({
                        width: canvas.width,
                        height: canvas.height,
                        x: rect.x,
                        y: rect. y
                    });
                });
                
                // 3. æ£€æµ‹SVGå…ƒç´ 
                var svgs = document.querySelectorAll('svg');
                svgs.forEach(function(svg) {
                    var rect = svg. getBoundingClientRect();
                    if (rect.width > 0 && rect.height > 0) {
                        result.svgElements.push({
                            width: rect.width,
                            height: rect.height,
                            x: rect.x,
                            y: rect.y,
                            innerHTML: svg.innerHTML. substring(0, 200)
                        });
                    }
                });
                
                // 4. æ£€æµ‹iframe
                var iframes = document. querySelectorAll('iframe');
                iframes.forEach(function(iframe) {
                    result.iframes.push({
                        src: iframe.src,
                        width: iframe.width,
                        height: iframe.height
                    });
                });
                
                // 5. æ£€æµ‹Shadow DOM
                allElements.forEach(function(elem) {
                    if (elem. shadowRoot) {
                        result.shadowDOMs.push({
                            tag: elem.tagName,
                            class: elem.className,
                            childCount: elem.shadowRoot.childElementCount
                        });
                    }
                });
                
                // 6. æ£€æµ‹å¯ç–‘çš„æ•°å­—å…ƒç´ 
                allElements.forEach(function(elem) {
                    var rect = elem.getBoundingClientRect();
                    if (rect. width > 20 && rect.width < 100 && 
                        rect. height > 10 && rect.height < 50 &&
                        rect.y > 200 && rect.y < 1500) {
                        
                        var text = elem.innerText || elem.textContent || '';
                        var style = window.getComputedStyle(elem);
                        
                        // æ£€æŸ¥æ˜¯å¦æœ‰å¼‚å¸¸
                        if (text.trim() === '' && elem.children.length === 0) {
                            // ç©ºå…ƒç´ ä½†æœ‰å°ºå¯¸ï¼Œå¯èƒ½ç”¨å…¶ä»–æ–¹å¼æ˜¾ç¤ºå†…å®¹
                            result.suspiciousElements.push({
                                tag: elem.tagName,
                                class: elem.className,
                                id: elem.id,
                                x: Math.round(rect.x),
                                y: Math.round(rect. y),
                                width: Math.round(rect.width),
                                height: Math.round(rect.height),
                                fontFamily: style.fontFamily,
                                bgImage: style.backgroundImage !== 'none',
                                reason: 'empty_with_size'
                            });
                        }
                    }
                });
                
                return result;
            }
            return diagnosePage();
        """)
        
        log_callback(f"\nğŸ“Š è¯Šæ–­ç»“æœ:")
        log_callback(f"  è‡ªå®šä¹‰å­—ä½“: {len(diagnosis.get('customFonts', []))} ä¸ª")
        for font in diagnosis.get('customFonts', [])[:5]:
            log_callback(f"    - {font}")
        
        log_callback(f"  Canvaså…ƒç´ : {len(diagnosis.get('canvasElements', []))} ä¸ª")
        log_callback(f"  SVGå…ƒç´ : {len(diagnosis. get('svgElements', []))} ä¸ª")
        log_callback(f"  CSS Content: {len(diagnosis.get('cssContentElements', []))} ä¸ª")
        log_callback(f"  èƒŒæ™¯å›¾ç‰‡: {len(diagnosis.get('backgroundImages', []))} ä¸ª")
        log_callback(f"  iframe: {len(diagnosis.get('iframes', []))} ä¸ª")
        log_callback(f"  Shadow DOM: {len(diagnosis. get('shadowDOMs', []))} ä¸ª")
        log_callback(f"  å¯ç–‘å…ƒç´ : {len(diagnosis.get('suspiciousElements', []))} ä¸ª")
        
        return diagnosis

    def get_all_odds_data(self):
        """è·å–é¡µé¢ä¸Šæ‰€æœ‰æ°´ä½æ•°æ® - æ”¯æŒå¤šç§åçˆ¬è™«æŠ€æœ¯"""
        try:
            # å…ˆæ»šåŠ¨é¡µé¢è§¦å‘æ‡’åŠ è½½
            self.driver.execute_script("""
                window.scrollTo(0, 500);
                setTimeout(function() { window.scrollTo(0, 0); }, 300);
            """)
            time.sleep(1)
            
            data = self.driver.execute_script("""
                function getAllOddsData() {
                    var matches = [];
                    var currentLeague = '';
                    var matchId = 0;
                    var allTextData = [];
                    var debugInfo = {
                        method: 'unknown',
                        fontMapped: 0,
                        canvasOCR: 0,
                        cssContent: 0,
                        directText: 0
                    };
                    
                    // ============ æ–¹æ³•1: æ£€æµ‹å¹¶è§£æè‡ªå®šä¹‰å­—ä½“ ============
                    function tryDecodeFontText(element) {
                        var style = window.getComputedStyle(element);
                        var fontFamily = style.fontFamily;
                        var text = element.textContent || '';
                        
                        // æ£€æŸ¥æ˜¯å¦ä½¿ç”¨è‡ªå®šä¹‰å­—ä½“
                        if (fontFamily && (fontFamily.includes('iconfont') || 
                            fontFamily.includes('odds') || 
                            fontFamily.includes('num') ||
                            fontFamily.includes('digit'))) {
                            
                            // å°è¯•è·å–Unicodeç ç‚¹
                            var decoded = '';
                            for (var i = 0; i < text.length; i++) {
                                var code = text.charCodeAt(i);
                                // è‡ªå®šä¹‰å­—ä½“é€šå¸¸æ˜ å°„åˆ°ç§æœ‰åŒºåŸŸ E000-F8FF
                                if (code >= 0xE000 && code <= 0xF8FF) {
                                    // éœ€è¦å­—ä½“æ˜ å°„è¡¨ï¼Œè¿™é‡Œå°è¯•å¸¸è§æ˜ å°„
                                    var mapped = code - 0xE000;
                                    if (mapped >= 0 && mapped <= 9) {
                                        decoded += mapped. toString();
                                    } else {
                                        decoded += text[i];
                                    }
                                } else {
                                    decoded += text[i];
                                }
                            }
                            
                            if (decoded !== text) {
                                debugInfo.fontMapped++;
                                return decoded;
                            }
                        }
                        
                        return null;
                    }
                    
                    // ============ æ–¹æ³•2: ä»CSS contentè·å– ============
                    function getCSSContent(element) {
                        try {
                            var before = window.getComputedStyle(element, '::before').content;
                            var after = window.getComputedStyle(element, '::after').content;
                            
                            var result = '';
                            
                            if (before && before !== 'none' && before !== 'normal') {
                                result += before. replace(/['"]/g, '');
                            }
                            
                            if (after && after !== 'none' && after !== 'normal') {
                                result += after.replace(/['"]/g, '');
                            }
                            
                            if (result) {
                                debugInfo.cssContent++;
                            }
                            
                            return result;
                        } catch(e) {
                            return '';
                        }
                    }
                    
                    // ============ æ–¹æ³•3: ä»dataå±æ€§è·å– ============
                    function getDataAttributes(element) {
                        var attrs = ['data-value', 'data-odds', 'data-num', 'data-price', 
                                    'data-text', 'data-content', 'value', 'data-v'];
                        
                        for (var i = 0; i < attrs.length; i++) {
                            var val = element.getAttribute(attrs[i]);
                            if (val && /\\d/. test(val)) {
                                return val;
                            }
                        }
                        
                        // æ£€æŸ¥æ‰€æœ‰data-*å±æ€§
                        for (var j = 0; j < element.attributes.length; j++) {
                            var attr = element. attributes[j];
                            if (attr.name.startsWith('data-') && /^[\\d\\.]+$/.test(attr.value)) {
                                return attr. value;
                            }
                        }
                        
                        return null;
                    }
                    
                    // ============ æ–¹æ³•4: ä»ariaå±æ€§è·å– ============
                    function getAriaLabel(element) {
                        var ariaLabel = element.getAttribute('aria-label');
                        var ariaValue = element.getAttribute('aria-valuenow');
                        var title = element.getAttribute('title');
                        
                        return ariaLabel || ariaValue || title || null;
                    }
                    
                    // ============ æ–¹æ³•5: ä»å­å…ƒç´ æ‹¼æ¥ ============
                    function getTextFromChildren(element) {
                        var text = '';
                        var children = element.querySelectorAll('*');
                        
                        children.forEach(function(child) {
                            if (child.children.length === 0) {
                                var childText = child.textContent || '';
                                var cssContent = getCSSContent(child);
                                var dataAttr = getDataAttributes(child);
                                
                                text += cssContent || dataAttr || childText;
                            }
                        });
                        
                        return text. trim();
                    }
                    
                    // ============ æ–¹æ³•6: é€šè¿‡ä½ç½®å…³ç³»è·å– ============
                    function getTextByPosition(element) {
                        var rect = element.getBoundingClientRect();
                        
                        // æŸ¥æ‰¾é‡å çš„æ–‡æœ¬å…ƒç´ 
                        var elementsAtPoint = document.elementsFromPoint(
                            rect.x + rect. width / 2,
                            rect.y + rect.height / 2
                        );
                        
                        for (var i = 0; i < elementsAtPoint.length; i++) {
                            var el = elementsAtPoint[i];
                            if (el !== element) {
                                var text = el.textContent || '';
                                if (/^\\d\\.\\d{2}$/.test(text. trim())) {
                                    return text.trim();
                                }
                            }
                        }
                        
                        return null;
                    }
                    
                    // ============ æ–¹æ³•7: ä»æ ·å¼è®¡ç®—å€¼è·å– ============
                    function getFromComputedStyle(element) {
                        try {
                            var style = window.getComputedStyle(element);
                            
                            // æ£€æŸ¥contentå±æ€§
                            var content = style.content;
                            if (content && content !== 'none' && content !== 'normal') {
                                return content. replace(/['"]/g, '');
                            }
                            
                            // æ£€æŸ¥-webkit-text-fill-colorç­‰
                            // æœ‰äº›ç½‘ç«™é€šè¿‡clip-pathéšè—çœŸå®æ–‡æœ¬
                            
                        } catch(e) {}
                        
                        return null;
                    }
                    
                    // ============ ç»¼åˆè·å–æ–‡æœ¬çš„å‡½æ•° ============
                    function getElementText(element) {
                        var text = '';
                        
                        // å°è¯•æ‰€æœ‰æ–¹æ³•
                        var methods = [
                            function() { return getDataAttributes(element); },
                            function() { return getAriaLabel(element); },
                            function() { return getCSSContent(element); },
                            function() { return tryDecodeFontText(element); },
                            function() { return getFromComputedStyle(element); },
                            function() { return getTextByPosition(element); },
                            function() { return getTextFromChildren(element); },
                            function() { 
                                var t = element.innerText || element.textContent || '';
                                return t.split('\\n')[0].trim();
                            }
                        ];
                        
                        for (var i = 0; i < methods.length; i++) {
                            try {
                                var result = methods[i]();
                                if (result && result. trim()) {
                                    text = result.trim();
                                    if (/\\d/.test(text)) {
                                        // åŒ…å«æ•°å­—ï¼Œå¯èƒ½æ˜¯æˆ‘ä»¬è¦çš„
                                        if (i === methods.length - 1) {
                                            debugInfo.directText++;
                                        }
                                        break;
                                    }
                                }
                            } catch(e) {}
                        }
                        
                        return text;
                    }
                    
                    // ============ éå†é¡µé¢å…ƒç´  ============
                    function traverseDOM(container) {
                        if (!container) container = document. body;
                        
                        var elements = container.querySelectorAll('*');
                        
                        elements.forEach(function(element) {
                            try {
                                var rect = element.getBoundingClientRect();
                                
                                // è·³è¿‡ä¸å¯è§å…ƒç´ 
                                if (rect.width <= 0 || rect.height <= 0) return;
                                if (rect.y < 50 || rect.y > 2500) return;
                                
                                var text = getElementText(element);
                                
                                if (text && text.length > 0 && text. length < 50) {
                                    allTextData.push({
                                        text: text,
                                        x: Math.round(rect.x),
                                        y: Math.round(rect.y),
                                        width: Math.round(rect.width),
                                        height: Math.round(rect.height),
                                        tagName: element.tagName,
                                        className: element.className || '',
                                        id: element.id || ''
                                    });
                                }
                                
                                // æ£€æŸ¥Shadow DOM
                                if (element. shadowRoot) {
                                    traverseDOM(element.shadowRoot);
                                }
                            } catch(e) {}
                        });
                    }
                    
                    // ============ ç‰¹æ®Šå¤„ç†:  å°è¯•è·å–ç›®æ ‡å®¹å™¨ ============
                    function trySpecificPaths() {
                        var paths = [
                            '/html/body/div/div[3]/div[3]/div[2]/div[3]/div/div[2]',
                            '//div[contains(@class, "odds")]',
                            '//div[contains(@class, "match")]',
                            '//div[contains(@class, "event")]',
                            '//table[contains(@class, "odds")]//td'
                        ];
                        
                        paths.forEach(function(xpath) {
                            try {
                                var result = document.evaluate(
                                    xpath, document, null,
                                    XPathResult. ORDERED_NODE_SNAPSHOT_TYPE, null
                                );
                                
                                for (var i = 0; i < result.snapshotLength; i++) {
                                    var elem = result.snapshotItem(i);
                                    if (elem) {
                                        traverseDOM(elem);
                                    }
                                }
                            } catch(e) {}
                        });
                    }
                    
                    // ============ ç‰¹æ®Šå¤„ç†: æ£€æŸ¥iframe ============
                    function checkIframes() {
                        var iframes = document.querySelectorAll('iframe');
                        iframes. forEach(function(iframe) {
                            try {
                                var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                                if (iframeDoc) {
                                    traverseDOM(iframeDoc. body);
                                }
                            } catch(e) {
                                // è·¨åŸŸiframeæ— æ³•è®¿é—®
                            }
                        });
                    }
                    
                    // æ‰§è¡Œéå†
                    traverseDOM(document. body);
                    trySpecificPaths();
                    checkIframes();
                    
                    // å»é‡
                    var seen = new Set();
                    var uniqueData = [];
                    allTextData.forEach(function(item) {
                        var key = item.text + '_' + item.x + '_' + item.y;
                        if (!seen.has(key)) {
                            seen.add(key);
                            uniqueData.push(item);
                        }
                    });
                    allTextData = uniqueData;
                    
                    // ============ è§£ææ¯”èµ›æ•°æ® ============
                    var oddsPattern = /^\\d\\.\\d{2}$/;
                    var handicapPattern = /^[+-]?\\d+(\\.\\d)?(\\/(\\d+(\\.\\d)?))?$/;
                    var handicapWithText = /^(å¤§|å°|ä¸»|å®¢)\\s*\\d+(\\.\\d)?(\\/(\\d+(\\.\\d)?))?$/;
                    var timePattern = /(ä¸ŠåŠåœº|ä¸‹åŠåœº|ä¸­åœº|åŠåœº|ç¬¬[ä¸€äºŒä¸‰å››1-4]èŠ‚)\\s*\\d+/;
                    var leaguePattern = /(æ¯|è”èµ›|U23|U20|è¶…çº§|ç”²çº§|ä¹™çº§|äºšæ´²|NBA|CBA|è¶³çƒ|ç¯®çƒ)/i;
                    
                    // æŒ‰Yåæ ‡åˆ†ç»„
                    var rowGroups = {};
                    allTextData.forEach(function(item) {
                        var rowKey = Math.round(item.y / 22) * 22;
                        if (! rowGroups[rowKey]) {
                            rowGroups[rowKey] = [];
                        }
                        rowGroups[rowKey].push(item);
                    });
                    
                    var sortedYs = Object.keys(rowGroups).map(Number).sort(function(a,b){return a-b;});
                    
                    // è§£æ
                    var currentMatch = null;
                    
                    sortedYs.forEach(function(y) {
                        var row = rowGroups[y];
                        row.sort(function(a,b){return a.x - b.x;});
                        
                        // æ£€æµ‹è”èµ›
                        var leagueItem = row.find(function(item) {
                            return leaguePattern.test(item. text) && item.text.length > 3;
                        });
                        if (leagueItem && leagueItem.text.length > 5) {
                            currentLeague = leagueItem.text;
                        }
                        
                        // æ£€æµ‹æ¯”èµ›æ—¶é—´
                        var timeItem = row.find(function(item) {
                            return timePattern. test(item.text);
                        });
                        
                        if (timeItem) {
                            if (currentMatch && currentMatch.team1) {
                                matches.push(currentMatch);
                            }
                            
                            matchId++;
                            currentMatch = {
                                id: matchId,
                                league: currentLeague,
                                time: timeItem.text,
                                team1: '',
                                team1Score: '',
                                team2: '',
                                team2Score:  '',
                                team1Odds: [],
                                team2Odds:  []
                            };
                            return;
                        }
                        
                        if (! currentMatch) return;
                        
                        // æ”¶é›†æ°´ä½
                        var rowOdds = [];
                        var rowHandicaps = [];
                        var teamName = '';
                        var score = '';
                        
                        row.forEach(function(item) {
                            var t = item.text;
                            
                            if (oddsPattern.test(t)) {
                                var val = parseFloat(t);
                                if (val >= 0.01 && val <= 50) {
                                    rowOdds.push({
                                        value: val,
                                        text: t,
                                        x: item.x,
                                        y: item.y
                                    });
                                }
                            }
                            
                            if ((handicapPattern.test(t) || handicapWithText.test(t)) && !oddsPattern.test(t)) {
                                rowHandicaps.push({
                                    value: t,
                                    x: item.x
                                });
                            }
                            
                            if (t.length >= 2 && t.length <= 20 &&
                                ! oddsPattern.test(t) &&
                                !handicapPattern. test(t) &&
                                !handicapWithText.test(t) &&
                                !/^\\d+$/.test(t) &&
                                ! /(è®©çƒ|æ€»åˆ†|å¾—åˆ†|ä¸‹åŠåœº|ä¸ŠåŠåœº|ç¬¬[1-4]èŠ‚|å¤§|å°|ä¸»|å®¢|å•|åŒ|æ»šçƒ|ç‹¬èµ¢)/.test(t) &&
                                item.x < 300) {
                                if (/[\\u4e00-\\u9fa5]/.test(t) || /^[A-Z]/. test(t)) {
                                    teamName = t;
                                }
                            }
                            
                            if (/^\\d{1,3}$/.test(t) && item.x < 120) {
                                var num = parseInt(t);
                                if (num <= 300) {
                                    score = t;
                                }
                            }
                        });
                        
                        // åˆ†é…ç›˜å£ç±»å‹
                        var columnDefs = [
                            {name: 'è®©çƒ', min: 300, max: 420},
                            {name: 'å¤§å°', min: 420, max: 540},
                            {name: 'ç‹¬èµ¢', min: 540, max: 680},
                            {name: 'ä¸‹ä¸ªè¿›çƒ', min: 680, max: 800},
                            {name: 'åŒæ–¹çƒé˜Ÿè¿›çƒ', min: 800, max: 920},
                            {name: 'å•åŒ', min: 920, max:  1020},
                            {name: 'é˜Ÿä¼1è¿›çƒ', min: 1020, max: 1140},
                            {name: 'é˜Ÿä¼2è¿›çƒ', min: 1140, max: 1300}
                        ];
                        
                        var processedOdds = rowOdds.map(function(odds) {
                            var betType = 'å…¶ä»–';
                            for (var i = 0; i < columnDefs.length; i++) {
                                if (odds.x >= columnDefs[i].min && odds.x < columnDefs[i].max) {
                                    betType = columnDefs[i].name;
                                    break;
                                }
                            }
                            
                            var handicap = '';
                            for (var j = 0; j < rowHandicaps.length; j++) {
                                if (Math.abs(rowHandicaps[j].x - odds.x) < 100) {
                                    handicap = rowHandicaps[j]. value;
                                    break;
                                }
                            }
                            
                            return {
                                value: odds.value,
                                text: odds.text,
                                betType: betType,
                                handicap: handicap,
                                x: odds.x,
                                y: odds.y
                            };
                        });
                        
                        if (teamName) {
                            if (! currentMatch.team1) {
                                currentMatch.team1 = teamName;
                                currentMatch.team1Score = score;
                                currentMatch.team1Odds = processedOdds;
                            } else if (!currentMatch.team2) {
                                currentMatch.team2 = teamName;
                                currentMatch.team2Score = score;
                                currentMatch.team2Odds = processedOdds;
                            }
                        } else if (processedOdds.length > 0) {
                            if (currentMatch.team1 && ! currentMatch.team2) {
                                currentMatch.team1Odds = currentMatch.team1Odds.concat(processedOdds);
                            } else if (currentMatch.team2) {
                                currentMatch.team2Odds = currentMatch.team2Odds.concat(processedOdds);
                            }
                        }
                    });
                    
                    if (currentMatch && currentMatch.team1) {
                        matches.push(currentMatch);
                    }
                    
                    // ç»Ÿè®¡
                    var totalOdds = 0;
                    matches.forEach(function(m) {
                        totalOdds += (m.team1Odds ?  m.team1Odds.length : 0);
                        totalOdds += (m.team2Odds ?  m.team2Odds.length : 0);
                    });
                    
                    debugInfo.method = 'comprehensive';
                    
                    return {
                        matches: matches,
                        total: matches.length,
                        totalOdds: totalOdds,
                        debug: {
                            totalElements: allTextData.length,
                            rowCount: sortedYs.length,
                            oddsFound: totalOdds,
                            fontMapped: debugInfo.fontMapped,
                            cssContent: debugInfo.cssContent,
                            directText: debugInfo. directText,
                            method:  debugInfo.method
                        },
                        timestamp: new Date().toISOString()
                    };
                }
                return getAllOddsData();
            """)
            
            if data: 
                self.current_matches = data.get('matches', [])
            
            return data
            
        except Exception as e: 
            print(f"Error:  {e}")
            return None

    def click_odds_element(self, odds_text, x, y, log_callback):
        try:
            result = self.driver.execute_script(f"""
                var targetValue = '{odds_text}';
                var targetX = {x};
                var targetY = {y};
                
                var allElements = document.querySelectorAll('*');
                
                for (var i = 0; i < allElements.length; i++) {{
                    var elem = allElements[i];
                    var text = (elem.innerText || '').trim();
                    
                    if (text === targetValue && elem.offsetWidth > 0 && elem.offsetHeight > 0) {{
                        var rect = elem.getBoundingClientRect();
                        
                        if (Math.abs(rect.x - targetX) < 30 && Math.abs(rect. y - targetY) < 20) {{
                            elem.scrollIntoView({{behavior: 'smooth', block:  'center'}});
                            elem.click();
                            return {{success: true, value: text}};
                        }}
                    }}
                }}
                
                return {{success: false}};
            """)
            
            return result
            
        except Exception as e:
            return {'success': False}

    def place_bet(self, amount, log_callback):
        try:
            time.sleep(1)
            
            input_result = self.driver.execute_script(f"""
                var amount = {amount};
                var inputs = document.querySelectorAll('input');
                
                for (var input of inputs) {{
                    var visible = input.offsetWidth > 0 && input.offsetHeight > 0;
                    if (visible && input.type !== 'hidden') {{
                        input.value = '';
                        input.focus();
                        input.value = amount;
                        input. dispatchEvent(new Event('input', {{bubbles: true}}));
                        input.dispatchEvent(new Event('change', {{bubbles: true}}));
                        return {{success:  true}};
                    }}
                }}
                return {{success: false}};
            """)
            
            if not input_result. get('success'):
                log_callback(f"  âš  è¾“å…¥é‡‘é¢å¤±è´¥")
                return False
            
            log_callback(f"  âœ“ å·²è¾“å…¥é‡‘é¢: {amount}")
            time.sleep(0.5)
            
            confirm_result = self.driver.execute_script("""
                var buttons = document.querySelectorAll('button, div, span, a');
                
                for (var btn of buttons) {
                    var text = (btn.innerText || '').trim();
                    var visible = btn.offsetWidth > 0 && btn.offsetHeight > 0;
                    
                    if (visible && (text === 'ä¸‹æ³¨' || text === 'ç¡®è®¤' || text === 'ç¡®å®š' || text === 'æŠ•æ³¨')) {
                        btn.click();
                        return {success: true, buttonText: text};
                    }
                }
                return {success: false};
            """)
            
            if confirm_result.get('success'):
                log_callback(f"  âœ“ å·²ç‚¹å‡»:  {confirm_result.get('buttonText')}")
                return True
            
            return False
            
        except Exception as e:
            log_callback(f"  âœ— ä¸‹æ³¨å‡ºé”™: {e}")
            return False

    def check_and_auto_bet(self, log_callback):
        if not self.auto_bet_enabled or not self.threshold_settings:
            return
        
        for match in self.current_matches:
            match_id = match.get('id')
            team1 = match.get('team1', '')
            team2 = match.get('team2', '')
            
            for odds in match.get('team1Odds', []):
                bet_type = odds.get('betType', '')
                setting_key = f"{match_id}_{bet_type}_ä¸»"
                threshold = self.threshold_settings.get(setting_key)
                
                if threshold and odds['value'] >= threshold:
                    bet_key = f"{setting_key}_{odds['text']}_{datetime.now().strftime('%Y%m%d%H%M')}"
                    
                    if bet_key not in self.bet_history:
                        log_callback(f"\nğŸ¯ è§¦å‘è‡ªåŠ¨ä¸‹æ³¨!")
                        log_callback(f"   æ¯”èµ›: {team1} vs {team2}")
                        log_callback(f"   ç›˜å£: {bet_type} {odds. get('handicap', '')}")
                        log_callback(f"   æ–¹å‘: ä¸»é˜Ÿ ({team1})")
                        log_callback(f"   æ°´ä½: {odds['text']} (é˜ˆå€¼: {threshold})")
                        
                        click_result = self.click_odds_element(odds['text'], odds['x'], odds['y'], log_callback)
                        
                        if click_result.get('success'):
                            if self.place_bet(self.bet_amount, log_callback):
                                self.bet_history. append(bet_key)
                                log_callback(f"  âœ“âœ“ ä¸‹æ³¨æˆåŠŸ!  é‡‘é¢: {self.bet_amount} RMB")
                                return True
            
            for odds in match.get('team2Odds', []):
                bet_type = odds. get('betType', '')
                setting_key = f"{match_id}_{bet_type}_å®¢"
                threshold = self.threshold_settings.get(setting_key)
                
                if threshold and odds['value'] >= threshold: 
                    bet_key = f"{setting_key}_{odds['text']}_{datetime.now().strftime('%Y%m%d%H%M')}"
                    
                    if bet_key not in self.bet_history:
                        log_callback(f"\nğŸ¯ è§¦å‘è‡ªåŠ¨ä¸‹æ³¨!")
                        log_callback(f"   æ¯”èµ›: {team1} vs {team2}")
                        log_callback(f"   ç›˜å£: {bet_type} {odds.get('handicap', '')}")
                        log_callback(f"   æ–¹å‘:  å®¢é˜Ÿ ({team2})")
                        log_callback(f"   æ°´ä½:  {odds['text']} (é˜ˆå€¼: {threshold})")
                        
                        click_result = self.click_odds_element(odds['text'], odds['x'], odds['y'], log_callback)
                        
                        if click_result.get('success'):
                            if self.place_bet(self.bet_amount, log_callback):
                                self.bet_history.append(bet_key)
                                log_callback(f"  âœ“âœ“ ä¸‹æ³¨æˆåŠŸ! é‡‘é¢: {self. bet_amount} RMB")
                                return True
        
        return False

    def monitor_realtime(self, interval, log_callback, update_callback):
        log_callback(f"\n{'='*50}")
        log_callback(f"ğŸš€ å¼€å§‹å®æ—¶ç›‘æ§æ°´ä½")
        log_callback(f"   åˆ·æ–°é—´éš”: {interval} ç§’")
        log_callback(f"{'='*50}\n")
        
        while self.is_running:
            try: 
                data = self.get_all_odds_data()
                
                if data:
                    update_callback(data)
                    
                    if self.auto_bet_enabled: 
                        self.check_and_auto_bet(log_callback)
                
                time.sleep(interval)
                
            except Exception as e: 
                log_callback(f"âœ— ç›‘æ§é”™è¯¯: {str(e)}")
                time. sleep(interval)
        
        log_callback("\nç›‘æ§å·²åœæ­¢")
    
    def stop(self):
        self.is_running = False
        if self.driver:
            try:
                self.driver.quit()
            except:
                pass


# ================== GUI ç±» ==================
class BettingBotGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("æ»šçƒæ°´ä½å®æ—¶ç›‘æ§ç³»ç»Ÿ")
        self.root.geometry("1800x950")
        self.root.configure(bg='#1a1a2e')
        
        self.bot = BettingBot()
        self.monitor_thread = None
        self. threshold_entries = {}
        
        self.bet_types = ['è®©çƒ', 'å¤§å°', 'ç‹¬èµ¢', 'ä¸‹ä¸ªè¿›çƒ', 'åŒæ–¹çƒé˜Ÿè¿›çƒ', 'å•åŒ',
                         'é˜Ÿä¼1è¿›çƒ', 'é˜Ÿä¼2è¿›çƒ', 'æ€»åˆ†', 'ç¬¬1é˜Ÿå¾—åˆ†', 'ç¬¬2é˜Ÿå¾—åˆ†',
                         'è®©çƒä¸‹åŠåœº', 'æ€»åˆ†ä¸‹åŠåœº', 'è®©çƒä¸ŠåŠåœº', 'å¤§å°ä¸ŠåŠåœº']
        
        self.create_widgets()
    
    def create_widgets(self):
        # æ ‡é¢˜
        title_frame = tk.Frame(self.root, bg='#1a1a2e')
        title_frame.pack(fill='x', padx=20, pady=10)
        
        tk.Label(title_frame, text="ğŸ¯ æ»šçƒæ°´ä½å®æ—¶ç›‘æ§ç³»ç»Ÿ", bg='#1a1a2e', fg='#00ff88',
                font=('Microsoft YaHei UI', 20, 'bold')).pack()
        tk.Label(title_frame, text="æ”¯æŒåçˆ¬è™«æ£€æµ‹ï¼Œå¯é’ˆå¯¹æ¯åœºæ¯”èµ›ã€æ¯ä¸ªç›˜å£ã€ä¸»é˜Ÿ/å®¢é˜Ÿåˆ†åˆ«è®¾ç½®æ°´ä½é˜ˆå€¼",
                bg='#1a1a2e', fg='#888888', font=('Microsoft YaHei UI', 9)).pack()
        
        # ä¸»å®¹å™¨
        main_container = tk.Frame(self.root, bg='#1a1a2e')
        main_container.pack(fill='both', expand=True, padx=20, pady=10)
        
        # å·¦ä¾§æ§åˆ¶é¢æ¿
        left_frame = tk.Frame(main_container, bg='#16213e', width=280)
        left_frame.pack(side='left', fill='y', padx=(0, 10))
        left_frame.pack_propagate(False)
        
        # ç™»å½•åŒºåŸŸ
        login_frame = tk.LabelFrame(left_frame, text="ğŸ” ç™»å½•", bg='#16213e',
                                   fg='#00ff88', font=('Microsoft YaHei UI', 11, 'bold'),
                                   padx=10, pady=10)
        login_frame.pack(fill='x', padx=10, pady=(10, 5))
        
        tk.Label(login_frame, text="ç”¨æˆ·å:", bg='#16213e', fg='#ffffff',
                font=('Microsoft YaHei UI', 10)).grid(row=0, column=0, sticky='w', pady=3)
        self.username_entry = tk.Entry(login_frame, bg='#0f3460', fg='#ffffff',
                                      font=('Consolas', 10), insertbackground='#ffffff',
                                      relief='flat', width=16)
        self.username_entry.grid(row=0, column=1, pady=3, padx=(5, 0))
        self.username_entry.insert(0, USERNAME)
        
        tk.Label(login_frame, text="å¯†ç :", bg='#16213e', fg='#ffffff',
                font=('Microsoft YaHei UI', 10)).grid(row=1, column=0, sticky='w', pady=3)
        self.password_entry = tk.Entry(login_frame, show="*", bg='#0f3460', fg='#ffffff',
                                      font=('Consolas', 10), insertbackground='#ffffff',
                                      relief='flat', width=16)
        self.password_entry. grid(row=1, column=1, pady=3, padx=(5, 0))
        self.password_entry.insert(0, PASSWORD)
        
        self.login_btn = tk.Button(login_frame, text="ç™»å½•", bg='#00ff88', fg='#000000',
                                  font=('Microsoft YaHei UI', 10, 'bold'), relief='flat',
                                  command=self.login, cursor='hand2', padx=15, pady=3)
        self.login_btn.grid(row=2, column=0, columnspan=2, pady=(8, 0))
        
        # ä¸‹æ³¨è®¾ç½®
        self.bet_frame = tk.LabelFrame(left_frame, text="ğŸ’° ä¸‹æ³¨è®¾ç½®", bg='#16213e',
                                      fg='#ff9900', font=('Microsoft YaHei UI', 11, 'bold'),
                                      padx=10, pady=10)
        
        tk.Label(self.bet_frame, text="ä¸‹æ³¨é‡‘é¢:", bg='#16213e', fg='#ffffff',
                font=('Microsoft YaHei UI', 10)).grid(row=0, column=0, sticky='w', pady=3)
        self.amount_entry = tk.Entry(self.bet_frame, bg='#0f3460', fg='#00ff88',
                                    font=('Consolas', 11, 'bold'), insertbackground='#ffffff',
                                    relief='flat', width=8)
        self.amount_entry.grid(row=0, column=1, pady=3, padx=(5, 0))
        self.amount_entry.insert(0, "2")
        tk.Label(self.bet_frame, text="RMB", bg='#16213e', fg='#888888',
                font=('Microsoft YaHei UI', 9)).grid(row=0, column=2, padx=3)
        
        tk.Label(self.bet_frame, text="åˆ·æ–°é—´éš”:", bg='#16213e', fg='#ffffff',
                font=('Microsoft YaHei UI', 10)).grid(row=1, column=0, sticky='w', pady=3)
        self.interval_entry = tk.Entry(self.bet_frame, bg='#0f3460', fg='#ffffff',
                                      font=('Consolas', 11), insertbackground='#ffffff',
                                      relief='flat', width=8)
        self.interval_entry.grid(row=1, column=1, pady=3, padx=(5, 0))
        self.interval_entry.insert(0, "1")
        tk.Label(self.bet_frame, text="ç§’", bg='#16213e', fg='#888888',
                font=('Microsoft YaHei UI', 9)).grid(row=1, column=2, padx=3)
        
        self.auto_bet_var = tk.BooleanVar(value=False)
        self.auto_bet_check = tk.Checkbutton(self. bet_frame, text="å¯ç”¨è‡ªåŠ¨ä¸‹æ³¨",
                                            variable=self.auto_bet_var,
                                            bg='#16213e', fg='#ff4444',
                                            selectcolor='#0f3460',
                                            activebackground='#16213e',
                                            font=('Microsoft YaHei UI', 10, 'bold'),
                                            command=self.toggle_auto_bet)
        self.auto_bet_check.grid(row=2, column=0, columnspan=3, pady=(8, 0), sticky='w')
        
        # æ§åˆ¶æŒ‰é’®
        self.control_frame = tk.Frame(left_frame, bg='#16213e')
        
        self.start_btn = tk.Button(self.control_frame, text="ğŸš€ å¼€å§‹ç›‘æ§", bg='#0088ff',
                                   fg='#ffffff', font=('Microsoft YaHei UI', 11, 'bold'),
                                   relief='flat', command=self.start_monitoring,
                                   cursor='hand2', pady=8)
        self.start_btn.pack(fill='x', pady=(0, 5))
        
        self.stop_btn = tk.Button(self.control_frame, text="â¹ åœæ­¢ç›‘æ§", bg='#ff4444',
                                  fg='#ffffff', font=('Microsoft YaHei UI', 11, 'bold'),
                                  relief='flat', command=self.stop_monitoring,
                                  cursor='hand2', pady=8, state='disabled')
        self.stop_btn.pack(fill='x', pady=(0, 5))
        
        self.refresh_btn = tk.Button(self.control_frame, text="ğŸ”„ åˆ·æ–°æ°´ä½", bg='#666666',
                                    fg='#ffffff', font=('Microsoft YaHei UI', 10),
                                    relief='flat', command=self.refresh_data,
                                    cursor='hand2', pady=6)
        self.refresh_btn.pack(fill='x', pady=(0, 5))
        
        self.diagnose_btn = tk.Button(self.control_frame, text="ğŸ” è¯Šæ–­é¡µé¢", bg='#ff6600',
                                     fg='#ffffff', font=('Microsoft YaHei UI', 10),
                                     relief='flat', command=self.diagnose_page,
                                     cursor='hand2', pady=6)
        self.diagnose_btn. pack(fill='x', pady=(0, 5))
        
        self.save_btn = tk.Button(self.control_frame, text="ğŸ’¾ ä¿å­˜é˜ˆå€¼è®¾ç½®", bg='#9933ff',
                                 fg='#ffffff', font=('Microsoft YaHei UI', 10),
                                 relief='flat', command=self.save_thresholds,
                                 cursor='hand2', pady=6)
        self.save_btn. pack(fill='x')
        
        # æ—¥å¿—åŒºåŸŸ
        log_frame = tk.LabelFrame(left_frame, text="ğŸ“‹ æ—¥å¿—", bg='#16213e',
                                 fg='#888888', font=('Microsoft YaHei UI', 10, 'bold'),
                                 padx=5, pady=5)
        log_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        self.log_text = scrolledtext.ScrolledText(log_frame, bg='#0f3460', fg='#00ff88',
                                                 font=('Consolas', 8), relief='flat',
                                                 height=12, wrap='word')
        self.log_text.pack(fill='both', expand=True)
        
        # å³ä¾§ - æ°´ä½æ•°æ®åŒºåŸŸ
        right_frame = tk.Frame(main_container, bg='#16213e')
        right_frame.pack(side='right', fill='both', expand=True)
        
        tk.Label(right_frame, text="ğŸ“Š å®æ—¶æ°´ä½æ•°æ®", bg='#16213e',
                font=('Microsoft YaHei UI', 12, 'bold'), fg='#00ff88').pack(anchor='w', pady=(0, 5))
        
        self.hint_label = tk.Label(right_frame,
                                  text="è¯·å…ˆç™»å½•\n\nç™»å½•åå°†æ˜¾ç¤ºæ‰€æœ‰æ»šçƒæ¯”èµ›çš„æ°´ä½æ•°æ®\n\nå¦‚æœæ— æ³•è·å–æ•°æ®ï¼Œè¯·ç‚¹å‡»ã€Œè¯Šæ–­é¡µé¢ã€æŒ‰é’®",
                                  bg='#16213e', fg='#888888',
                                  font=('Microsoft YaHei UI', 11), justify='center')
        self.hint_label.pack(pady=80)
        
        self.odds_canvas = None
        self.odds_inner_frame = None
        
        # çŠ¶æ€æ 
        status_frame = tk.Frame(self.root, bg='#0f3460', height=30)
        status_frame.pack(side='bottom', fill='x')
        
        self.status_label = tk.Label(status_frame, text="çŠ¶æ€: æœªç™»å½•", bg='#0f3460',
                                    fg='#888888', font=('Microsoft YaHei UI', 10),
                                    anchor='w', padx=20)
        self.status_label.pack(side='left', fill='y')
        
        self.time_label = tk.Label(status_frame, text="", bg='#0f3460',
                                  fg='#00ff88', font=('Microsoft YaHei UI', 10),
                                  anchor='e', padx=20)
        self.time_label.pack(side='right', fill='y')
    
    def create_odds_display_area(self, parent):
        self.hint_label.pack_forget()
        
        canvas_frame = tk.Frame(parent, bg='#16213e')
        canvas_frame.pack(fill='both', expand=True)
        
        self.odds_canvas = tk.Canvas(canvas_frame, bg='#0f3460', highlightthickness=0)
        scrollbar_y = tk.Scrollbar(canvas_frame, orient='vertical', command=self.odds_canvas.yview)
        scrollbar_x = tk.Scrollbar(canvas_frame, orient='horizontal', command=self.odds_canvas.xview)
        
        self. odds_inner_frame = tk.Frame(self.odds_canvas, bg='#0f3460')
        
        self.odds_canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)
        
        scrollbar_y.pack(side='right', fill='y')
        scrollbar_x.pack(side='bottom', fill='x')
        self.odds_canvas.pack(side='left', fill='both', expand=True)
        
        self.canvas_window = self.odds_canvas.create_window((0, 0), window=self.odds_inner_frame, anchor='nw')
        
        self.odds_inner_frame.bind('<Configure>', lambda e: self.odds_canvas. configure(scrollregion=self. odds_canvas.bbox('all')))
        self.odds_canvas.bind('<Configure>', lambda e: self.odds_canvas.itemconfig(self.canvas_window, width=e.width))
        self.odds_canvas.bind_all('<MouseWheel>', lambda e: self.odds_canvas.yview_scroll(int(-1*(e.delta/120)), 'units'))
    
    def format_odds_list(self, odds_list, bet_type):
        filtered = [o for o in odds_list if o. get('betType') == bet_type]
        if not filtered:
            return "--", []
        
        texts = []
        for o in filtered[: 4]: 
            h = o.get('handicap', '')
            if h:
                texts.append(f"{h} {o['text']}")
            else:
                texts.append(o['text'])
        
        return " | ".join(texts), filtered
    
    def update_odds_display(self, data):
        def update():
            if not self.odds_inner_frame:
                return
            
            matches = data.get('matches', [])
            total_odds = data.get('totalOdds', 0)
            debug = data.get('debug', {})
            timestamp = datetime.now().strftime('%H:%M:%S')
            
            self.time_label.config(text=f"æœ€åæ›´æ–°: {timestamp}")
            
            for widget in self.odds_inner_frame.winfo_children():
                widget.destroy()
            
            self.threshold_entries = {}
            
            # è°ƒè¯•ä¿¡æ¯
            debug_text = f"è°ƒè¯•:  å…ƒç´ ={debug.get('totalElements', 0)}, æ°´ä½={total_odds}"
            debug_text += f", å­—ä½“æ˜ å°„={debug.get('fontMapped', 0)}"
            debug_text += f", CSS={debug.get('cssContent', 0)}"
            debug_text += f", ç›´æ¥æ–‡æœ¬={debug.get('directText', 0)}"
            tk.Label(self.odds_inner_frame, text=debug_text,
                    bg='#0f3460', fg='#666666', font=('Consolas', 8)).pack(anchor='w', padx=10, pady=2)
            
            if not matches:
                tk.Label(self.odds_inner_frame, 
                        text="æš‚æ— æ¯”èµ›æ•°æ®\n\nå¯èƒ½åŸå› :\n1. é¡µé¢ä½¿ç”¨äº†åçˆ¬è™«æŠ€æœ¯ï¼ˆå­—ä½“æ··æ·†/Canvasæ¸²æŸ“ï¼‰\n2. æ•°æ®å°šæœªåŠ è½½å®Œæˆ\n3. è¯·ç‚¹å‡»ã€Œè¯Šæ–­é¡µé¢ã€æŸ¥çœ‹è¯¦æƒ…",
                        bg='#0f3460', fg='#888888', font=('Microsoft YaHei UI', 11)).pack(pady=20)
                return
            
            tk.Label(self.odds_inner_frame,
                    text=f"å…± {len(matches)} åœºæ¯”èµ›ï¼Œ{total_odds} ä¸ªæ°´ä½",
                    bg='#0f3460', fg='#00ff88', font=('Microsoft YaHei UI', 10, 'bold')).pack(anchor='w', padx=10, pady=5)
            
            current_league = ''
            
            for match in matches:
                match_id = match.get('id')
                league = match.get('league', '')
                team1 = match.get('team1', 'æœªçŸ¥')
                team2
