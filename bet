from selenium import webdriver
from selenium. webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from selenium.webdriver.common.action_chains import ActionChains
import time
import pickle
import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import threading
from datetime import datetime
import re
import json

# ================== é…ç½® ==================
URL = "https://mos055.com/"
USERNAME = "LJJ123123"
PASSWORD = "zz66688899"
COOKIES_FILE = "mos055_cookies.pkl"

# ================== BettingBot ç±» ==================
class BettingBot:
    def __init__(self):
        self.driver = None
        self.is_running = False
        self.is_logged_in = False
        self.wait = None
        self.auto_bet_enabled = False
        self.bet_amount = 2
        self.bet_history = []
        self.threshold_settings = {}
        self.current_matches = []
        self.font_map = {}

    def setup_driver(self, headless=False):
        options = webdriver.ChromeOptions()
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
        options.add_argument("--disable-blink-features=AutomationControlled")
        options.add_argument("--disable-gpu")
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        options.add_argument("--window-size=1920,1080")
        options.add_argument("user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")

        if headless:
            options.add_argument("--headless=new")

        self.driver = webdriver. Chrome(options=options)
        self.wait = WebDriverWait(self. driver, 60)

        self.driver.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {
            'source': '''
                Object.defineProperty(navigator, 'webdriver', {get: () => undefined});
                window.chrome = {runtime: {}};
            '''
        })

    def handle_password_popup(self, log_callback):
        log_callback("æ£€æµ‹å¹¶å¤„ç†ç®€æ˜“å¯†ç å¼¹çª—...")

        for attempt in range(15):
            try:
                popup_visible = self.driver.execute_script("""
                    var popup = document.getElementById('c_alert_modify');
                    if (popup) {
                        var style = window.getComputedStyle(popup);
                        return popup.offsetWidth > 0 && popup.offsetHeight > 0 &&
                               style.display !== 'none' && style.visibility !== 'hidden';
                    }
                    return false;
                """)

                if not popup_visible:
                    has_popup_text = self.driver.execute_script("""
                        return document.body.innerText.includes('ç®€æ˜“å¯†ç ') ||
                               document.body.innerText.includes('å¿«é€Ÿç™»å…¥');
                    """)
                    if not has_popup_text:
                        log_callback("âœ“ å¼¹çª—å·²å…³é—­æˆ–ä¸å­˜åœ¨")
                        return True

                result = self.driver.execute_script("""
                    var elements = document.querySelectorAll('div, button, span');
                    for (var elem of elements) {
                        if (elem.innerText.trim() === 'å¦' &&
                            elem.offsetWidth > 0 && elem.offsetHeight > 0) {
                            elem.click();
                            return {success: true};
                        }
                    }
                    return {success: false};
                """)
                if result.get('success'):
                    log_callback(f"  ç¬¬{attempt+1}æ¬¡ç‚¹å‡»æˆåŠŸ")
                    time.sleep(2)
                    continue

                time.sleep(1)
            except: 
                time.sleep(1)

        return False

    def wait_for_matches_to_load(self, log_callback):
        """ç­‰å¾…æ¯”èµ›æ•°æ®åŠ è½½å¹¶æ»šåŠ¨è§¦å‘"""
        log_callback("\nâ³ ç­‰å¾…æ¯”èµ›æ•°æ®åŠ è½½...")

        for attempt in range(10):
            time.sleep(2)

            # æ»šåŠ¨é¡µé¢è§¦å‘æ‡’åŠ è½½
            self.driver.execute_script("window.scrollTo(0, 800);")
            time.sleep(1)

            self.driver.execute_script("window.scrollTo(0, 1500);")
            time.sleep(1)

            self.driver.execute_script("window.scrollTo(0, 500);")
            time.sleep(1)

            # æ£€æŸ¥æ˜¯å¦æœ‰æ¯”èµ›æ•°æ®
            has_matches = self. driver.execute_script("""
                var elements = document.querySelectorAll('*');
                var foundMatch = false;

                for (var i = 0; i < elements.length; i++) {
                    var text = elements[i].textContent || '';
                    if (/(Esports|vs|FIFA|Real Madrid|Manchester|åŠåœº|ä¸ŠåŠåœº|ä¸‹åŠåœº|è®©çƒ|å¤§å°)/i.test(text) &&
                        text.length > 3 && text.length < 200) {
                        var rect = elements[i].getBoundingClientRect();
                        if (rect.y > 100 && rect.y < 3000 && rect.width > 50) {
                            foundMatch = true;
                            break;
                        }
                    }
                }

                return foundMatch;
            """)

            if has_matches:
                log_callback(f"âœ“ æ£€æµ‹åˆ°æ¯”èµ›æ•°æ® (å°è¯• {attempt + 1}/10)")
                time.sleep(2)
                return True

            log_callback(f"  å°è¯• {attempt + 1}/10 - æœªæ£€æµ‹åˆ°æ•°æ®ï¼Œç»§ç»­ç­‰å¾…...")

        log_callback("âš ï¸ ç­‰å¾…è¶…æ—¶ï¼Œä½†ç»§ç»­å°è¯•è·å–æ•°æ®")
        return False

    def decode_tahoma2_font(self, log_callback):
        """å°è¯•è§£ç  TAHOMA2 è‡ªå®šä¹‰å­—ä½“"""
        log_callback("\nğŸ”¤ åˆ†æ TAHOMA2 å­—ä½“...")

        font_map = self.driver.execute_script("""
            function decodeTahoma2() {
                var samples = [];

                var allElements = document.querySelectorAll('*');

                allElements.forEach(function(elem) {
                    var style = window.getComputedStyle(elem);
                    var fontFamily = style.fontFamily || '';

                    if (fontFamily.toUpperCase().includes('TAHOMA')) {
                        var rect = elem.getBoundingClientRect();
                        if (rect. width > 0 && rect. height > 0 && rect.y > 50 && rect.y < 2000) {
                            var text = elem.textContent || '';

                            var unicodeInfo = [];
                            for (var i = 0; i < Math.min(text.length, 30); i++) {
                                var code = text.charCodeAt(i);
                                unicodeInfo.push({
                                    char: text[i],
                                    code:  code,
                                    hex: '0x' + code.toString(16).toUpperCase(),
                                    isPrivate: (code >= 0xE000 && code <= 0xF8FF)
                                });
                            }

                            samples.push({
                                text: text. substring(0, 50),
                                innerHTML: elem. innerHTML. substring(0, 100),
                                x: Math. round(rect.x),
                                y: Math.round(rect.y),
                                width: Math.round(rect.width),
                                height: Math.round(rect.height),
                                fontFamily: fontFamily,
                                unicode: unicodeInfo,
                                tagName: elem. tagName,
                                className:  elem.className
                            });
                        }
                    }
                });

                samples.sort(function(a, b) { return a.y - b.y; });

                return {
                    samples: samples. slice(0, 50),
                    count: samples.length
                };
            }

            return decodeTahoma2();
        """)

        log_callback(f"  æ‰¾åˆ° {font_map.get('count', 0)} ä¸ªä½¿ç”¨ TAHOMA å­—ä½“çš„å…ƒç´ ")

        if font_map.get('samples'):
            for i, sample in enumerate(font_map['samples'][:5]):
                log_callback(f"\n  æ ·æœ¬ {i+1}:")
                log_callback(f"    ä½ç½®: ({sample['x']}, {sample['y']})")
                log_callback(f"    æ–‡æœ¬: [{sample['text']}]")
                if sample. get('unicode'):
                    unicode_str = ', '.join([f"{u['char']}({u['hex']})" for u in sample['unicode'][:10]])
                    log_callback(f"    Unicode:  {unicode_str}")
                    has_private = any(u['isPrivate'] for u in sample['unicode'])
                    if has_private:
                        log_callback(f"    âš ï¸ åŒ…å«ç§æœ‰Unicodeå­—ç¬¦!")

        return font_map

    def find_match_container(self, log_callback):
        """ç²¾ç¡®å®šä½æ¯”èµ›åˆ—è¡¨å®¹å™¨"""
        log_callback("\nğŸ¯ å®šä½æ¯”èµ›åˆ—è¡¨åŒºåŸŸ...")

        container_info = self.driver.execute_script("""
            function findMatchContainer() {
                var result = {
                    byClassName: [],
                    byContent: [],
                    allLargeContainers: []
                };

                // æ–¹æ³•1: é€šè¿‡ç±»åæŸ¥æ‰¾
                var classPatterns = ['match', 'event', 'game', 'odds', 'bet', 'league', 'sport'];
                classPatterns.forEach(function(pattern) {
                    var elems = document.querySelectorAll('[class*="' + pattern + '"]');
                    elems.forEach(function(elem) {
                        var rect = elem.getBoundingClientRect();
                        if (rect. height > 100 && rect.width > 400 && rect.y > 50 && rect.y < 1500) {
                            result.byClassName.push({
                                pattern: pattern,
                                className: elem.className. substring(0, 100),
                                tagName: elem.tagName,
                                y: Math.round(rect.y),
                                height: Math.round(rect.height),
                                width: Math. round(rect.width),
                                childCount: elem.children.length
                            });
                        }
                    });
                });

                // æ–¹æ³•2: é€šè¿‡å†…å®¹æŸ¥æ‰¾
                var keywords = ['è®©çƒ', 'å¤§å°', 'ç‹¬èµ¢', 'åŠåœº', 'vs', 'æ¯”åˆ†'];
                var allElements = document.querySelectorAll('*');

                allElements.forEach(function(elem) {
                    var text = elem.textContent || '';
                    keywords.forEach(function(keyword) {
                        if (text.includes(keyword)) {
                            var rect = elem.getBoundingClientRect();
                            if (rect.height > 50 && rect.width > 200 && rect.y > 50) {
                                result.byContent.push({
                                    keyword: keyword,
                                    tagName: elem.tagName,
                                    className: (elem.className || '').substring(0, 50),
                                    y: Math.round(rect.y),
                                    height: Math.round(rect.height),
                                    textPreview: text.substring(0, 50)
                                });
                            }
                        }
                    });
                });

                // æ–¹æ³•3: æŸ¥æ‰¾æ‰€æœ‰å¤§å®¹å™¨
                allElements.forEach(function(elem) {
                    var rect = elem.getBoundingClientRect();
                    if (rect.height > 200 && rect.width > 600 &&
                        rect.y > 100 && rect.y < 1000 &&
                        elem.children.length > 5) {
                        result.allLargeContainers.push({
                            tagName: elem.tagName,
                            className: (elem.className || '').substring(0, 80),
                            id: elem.id,
                            y: Math.round(rect. y),
                            height: Math.round(rect.height),
                            childCount: elem.children.length
                        });
                    }
                });

                return result;
            }

            return findMatchContainer();
        """)

        log_callback(f"  é€šè¿‡ç±»åæ‰¾åˆ°:  {len(container_info.get('byClassName', []))} ä¸ª")
        log_callback(f"  é€šè¿‡å†…å®¹æ‰¾åˆ°: {len(container_info.get('byContent', []))} ä¸ª")
        log_callback(f"  å¤§å®¹å™¨:  {len(container_info.get('allLargeContainers', []))} ä¸ª")

        for container in container_info.get('byClassName', [])[:3]:
            log_callback(f"    ç±»ååŒ¹é…: {container['pattern']} - {container['className'][: 40]}")

        for container in container_info. get('byContent', [])[:3]:
            log_callback(f"    å†…å®¹åŒ¹é…: {container['keyword']} - {container['textPreview']}")

        return container_info

    def login(self, username, password, log_callback):
        try:
            log_callback("æ­£åœ¨è®¿é—®ç™»å½•é¡µé¢...")
            self.driver.get(URL)
            time.sleep(8)

            username_field = self.wait.until(EC.element_to_be_clickable((By.ID, "usr")))
            log_callback("âœ“ æ‰¾åˆ°ç”¨æˆ·åè¾“å…¥æ¡†")
            self.driver.execute_script("arguments[0].value = arguments[1];", username_field, username)
            log_callback(f"âœ“ å·²è¾“å…¥ç”¨æˆ·å: {username}")

            password_field = self.wait.until(EC.element_to_be_clickable((By.ID, "pwd")))
            self.driver.execute_script("arguments[0].value = arguments[1];", password_field, password)
            log_callback("âœ“ å·²è¾“å…¥å¯†ç ")

            login_button = self.wait.until(EC. element_to_be_clickable((By.ID, "btn_login")))
            self.driver.execute_script("arguments[0].click();", login_button)
            log_callback("âœ“ å·²ç‚¹å‡»ç™»å½•æŒ‰é’®")

            log_callback("\nç­‰å¾…ç™»å½•å“åº”...")
            time.sleep(10)

            self.handle_password_popup(log_callback)
            time.sleep(3)

            log_callback("\nç­‰å¾…ä¸»é¡µé¢åŠ è½½...")
            for i in range(12):
                time.sleep(5)
                elapsed = (i + 1) * 5
                log_callback(f"  å·²ç­‰å¾… {elapsed} ç§’...")

                if elapsed % 10 == 0:
                    try:
                        found = self.driver.execute_script("""
                            var elements = document.querySelectorAll('*');
                            for (var elem of elements) {
                                var text = (elem.textContent || '').trim();
                                if (text === 'æ»šçƒ' && elem.offsetWidth > 0 && elem.offsetHeight > 0) {
                                    return true;
                                }
                            }
                            return false;
                        """)
                        if found:
                            log_callback(f"âœ“ é¡µé¢å·²åŠ è½½å®Œæˆ")
                            break
                    except:
                        pass

            log_callback(f"\nå½“å‰URL: {self.driver.current_url}")

            cookies = self.driver.get_cookies()
            with open(COOKIES_FILE, "wb") as f:
                pickle.dump(cookies, f)
            log_callback(f"âœ“ Cookies å·²ä¿å­˜")

            log_callback("\nè¿›å…¥æ»šçƒé¡µé¢...")
            time.sleep(3)

            click_result = self.driver.execute_script("""
                var elements = document.querySelectorAll('*');
                for (var elem of elements) {
                    var text = (elem.textContent || '').trim();
                    var visible = elem.offsetWidth > 0 && elem.offsetHeight > 0;
                    if (visible && text === 'æ»šçƒ') {
                        elem.scrollIntoView({behavior: 'smooth', block:  'center'});
                        elem.click();
                        return {success: true};
                    }
                }
                return {success: false};
            """)

            if click_result.get('success'):
                log_callback(f"âœ“ å·²ç‚¹å‡»æ»šçƒ")

            log_callback("ç­‰å¾…æ»šçƒé¡µé¢åŠ è½½...")
            time.sleep(10)

            # ç­‰å¾…æ¯”èµ›æ•°æ®åŠ è½½
            self.wait_for_matches_to_load(log_callback)

            self.is_logged_in = True
            log_callback("\nâœ“ ç™»å½•æµç¨‹å®Œæˆï¼")

            return True

        except Exception as e:
            log_callback(f"\nâœ— ç™»å½•å¤±è´¥: {str(e)}")
            return False

    def get_all_odds_data(self):
        """è·å–é¡µé¢ä¸Šæ‰€æœ‰æ°´ä½æ•°æ® - å¢å¼ºç‰ˆ"""
        try:
            # æ»šåŠ¨é¡µé¢è§¦å‘æ‡’åŠ è½½
            self.driver.execute_script("window.scrollTo(0, 800);")
            time.sleep(0.8)
            self.driver.execute_script("window.scrollTo(0, 400);")
            time.sleep(0.8)

            data = self.driver.execute_script("""
                function getAllOddsData() {
                    var matches = [];
                    var currentLeague = '';
                    var matchId = 0;
                    var allTextData = [];
                    var debugInfo = {
                        totalScanned: 0,
                        tahoma2Elements: 0,
                        fromDataAttr: 0,
                        fromPseudo: 0,
                        fromText: 0,
                        privateUnicode: 0
                    };

                    // ========== è·å–æ–‡æœ¬çš„å¤šç§æ–¹æ³• ==========
                    function getFromDataAttributes(elem) {
                        var attrs = ['data-value', 'data-odds', 'data-num', 'data-price',
                                    'data-text', 'data-content', 'data-v', 'data-o', 'data-bet'];

                        for (var i = 0; i < attrs.length; i++) {
                            var val = elem.getAttribute(attrs[i]);
                            if (val && /[\\d\\.]/.test(val)) {
                                debugInfo. fromDataAttr++;
                                return val;
                            }
                        }

                        for (var j = 0; j < elem. attributes.length; j++) {
                            var attr = elem.attributes[j];
                            if (attr.name. startsWith('data-') && /^[\\d\\.\\-\\+\\/]+$/.test(attr.value)) {
                                debugInfo. fromDataAttr++;
                                return attr.value;
                            }
                        }

                        return null;
                    }

                    function getFromPseudoElements(elem) {
                        try {
                            var before = window.getComputedStyle(elem, '::before').content;
                            var after = window.getComputedStyle(elem, '::after').content;

                            var result = '';

                            if (before && before !== 'none' && before !== 'normal') {
                                result += before. replace(/['"]/g, '');
                            }

                            if (after && after !== 'none' && after !== 'normal') {
                                result += after.replace(/['"]/g, '');
                            }

                            if (result && /\\d/. test(result)) {
                                debugInfo.fromPseudo++;
                                return result. trim();
                            }
                        } catch(e) {}

                        return null;
                    }

                    function tryDecodePrivateUnicode(text) {
                        if (!text) return null;

                        var decoded = '';
                        var hasPrivate = false;

                        for (var i = 0; i < text.length; i++) {
                            var code = text.charCodeAt(i);

                            if (code >= 0xE000 && code <= 0xF8FF) {
                                hasPrivate = true;
                                debugInfo.privateUnicode++;

                                // å°è¯•å¤šç§æ˜ å°„æ¨¡å¼
                                var mappings = [
                                    code - 0xE000,      // ç›´æ¥åç§»
                                    code - 0xE030,      // åç§»48 ('0'çš„ASCII)
                                    code & 0x000F,      // å–ä½4ä½
                                    (code - 0xE000) % 10  // å–æ¨¡10
                                ];

                                var mapped = mappings[0];
                                if (mapped >= 0 && mapped <= 9) {
                                    decoded += mapped. toString();
                                } else if (code === 0xE02E || code === 0xE02D) {
                                    decoded += '. ';
                                } else {
                                    decoded += '? ';
                                }
                            } else {
                                decoded += text[i];
                            }
                        }

                        if (hasPrivate) {
                            return decoded;
                        }

                        return null;
                    }

                    function getFromAriaOrTitle(elem) {
                        var ariaLabel = elem.getAttribute('aria-label');
                        var ariaValue = elem.getAttribute('aria-valuenow');
                        var title = elem.getAttribute('title');

                        var value = ariaLabel || ariaValue || title;
                        if (value && /\\d/.test(value)) {
                            return value;
                        }
                        return null;
                    }

                    function getElementText(elem) {
                        var methods = [
                            function() { return getFromDataAttributes(elem); },
                            function() { return getFromAriaOrTitle(elem); },
                            function() { return getFromPseudoElements(elem); },
                            function() {
                                var t = elem.textContent || '';
                                var decoded = tryDecodePrivateUnicode(t);
                                if (decoded) return decoded;
                                return null;
                            },
                            function() {
                                var t = elem. innerText || elem.textContent || '';
                                t = t.split('\\n')[0].trim();
                                if (t && t.length < 50) {
                                    debugInfo.fromText++;
                                    return t;
                                }
                                return null;
                            }
                        ];

                        for (var i = 0; i < methods.length; i++) {
                            try {
                                var result = methods[i]();
                                if (result && result.trim()) {
                                    return result.trim();
                                }
                            } catch(e) {}
                        }

                        return '';
                    }

                    // ========== éå†é¡µé¢å…ƒç´  ==========
                    var allElements = document.querySelectorAll('*');

                    allElements.forEach(function(elem) {
                        debugInfo.totalScanned++;

                        try {
                            var rect = elem.getBoundingClientRect();

                            if (rect.width <= 0 || rect.height <= 0) return;
                            if (rect.y < 50 || rect.y > 3000) return;

                            // æ£€æµ‹TAHOMAå­—ä½“
                            var style = window.getComputedStyle(elem);
                            var fontFamily = style.fontFamily || '';
                            if (fontFamily.toUpperCase().includes('TAHOMA')) {
                                debugInfo.tahoma2Elements++;
                            }

                            var text = getElementText(elem);

                            if (text && text.length > 0 && text.length < 80) {
                                allTextData.push({
                                    text: text,
                                    x: Math.round(rect.x),
                                    y: Math.round(rect.y),
                                    width: Math.round(rect.width),
                                    height: Math.round(rect.height),
                                    tagName: elem.tagName,
                                    className: elem.className || '',
                                    fontFamily:  fontFamily. substring(0, 30)
                                });
                            }
                        } catch(e) {}
                    });

                    // å»é‡
                    var seen = new Set();
                    var uniqueData = [];
                    allTextData.forEach(function(item) {
                        var key = item.text + '_' + item.x + '_' + item.y;
                        if (!seen.has(key)) {
                            seen.add(key);
                            uniqueData.push(item);
                        }
                    });
                    allTextData = uniqueData;

                    // ========== è§£ææ¯”èµ›æ•°æ® ==========
                    var oddsPattern = /^\\d+\\.\\d{2}$/;
                    var handicapPattern = /^[+-]?\\d+(\\.\\d)?(\\/(\\d+(\\.\\d)?))?$/;
                    var handicapWithText = /^(å¤§|å°|ä¸»|å®¢)\\s*[\\d\\.]+/;
                    var timePattern = /(ä¸ŠåŠåœº|ä¸‹åŠåœº|ä¸­åœº|åŠåœº|ç¬¬[ä¸€äºŒä¸‰å››1-4]èŠ‚)\\s*\\d+/;
                    var leaguePattern = /(æ¯|è”èµ›|U23|U20|è¶…çº§|ç”²çº§|ä¹™çº§|äºšæ´²|NBA|CBA|è¶³çƒ|ç¯®çƒ|Esports|ç”µç«)/i;

                    // æŒ‰Yåæ ‡åˆ†ç»„
                    var rowGroups = {};
                    allTextData.forEach(function(item) {
                        var rowKey = Math.round(item.y / 25) * 25;
                        if (!rowGroups[rowKey]) {
                            rowGroups[rowKey] = [];
                        }
                        rowGroups[rowKey].push(item);
                    });

                    var sortedYs = Object.keys(rowGroups).map(Number).sort(function(a,b){return a-b;});

                    // è§£æ
                    var currentMatch = null;

                    sortedYs.forEach(function(y) {
                        var row = rowGroups[y];
                        row.sort(function(a,b){return a.x - b.x;});

                        // æ£€æµ‹è”èµ›
                        var leagueItem = row.find(function(item) {
                            return leaguePattern.test(item. text) && item.text.length > 3;
                        });
                        if (leagueItem && leagueItem.text.length > 5) {
                            currentLeague = leagueItem.text;
                        }

                        // æ£€æµ‹æ¯”èµ›æ—¶é—´
                        var timeItem = row.find(function(item) {
                            return timePattern. test(item.text);
                        });

                        if (timeItem) {
                            if (currentMatch && currentMatch.team1) {
                                matches.push(currentMatch);
                            }

                            matchId++;
                            currentMatch = {
                                id: matchId,
                                league: currentLeague,
                                time: timeItem.text,
                                team1: '',
                                team1Score: '',
                                team2: '',
                                team2Score:  '',
                                team1Odds: [],
                                team2Odds:  []
                            };
                            return;
                        }

                        if (! currentMatch) return;

                        // æ”¶é›†æ°´ä½
                        var rowOdds = [];
                        var rowHandicaps = [];
                        var teamName = '';
                        var score = '';

                        row.forEach(function(item) {
                            var t = item.text;

                            if (oddsPattern.test(t)) {
                                var val = parseFloat(t);
                                if (val >= 0.01 && val <= 99) {
                                    rowOdds.push({
                                        value: val,
                                        text: t,
                                        x: item.x,
                                        y: item.y
                                    });
                                }
                            }

                            if ((handicapPattern.test(t) || handicapWithText.test(t)) && !oddsPattern.test(t)) {
                                rowHandicaps.push({
                                    value: t,
                                    x: item.x
                                });
                            }

                            if (t. length >= 2 && t.length <= 25 &&
                                !oddsPattern. test(t) &&
                                !handicapPattern. test(t) &&
                                !/^\\d+$/.test(t) &&
                                ! /(è®©çƒ|æ€»åˆ†|å¾—åˆ†|ä¸‹åŠåœº|ä¸ŠåŠåœº|å¤§|å°|ä¸»|å®¢|å•|åŒ|ç‹¬èµ¢|è§’çƒ|ç½šç‰Œ)/.test(t) &&
                                item.x < 350) {
                                if (/[\\u4e00-\\u9fa5A-Za-z]/.test(t)) {
                                    teamName = t;
                                }
                            }

                            if (/^\\d{1,3}$/.test(t) && item.x < 150) {
                                var num = parseInt(t);
                                if (num <= 300) {
                                    score = t;
                                }
                            }
                        });

                        // åˆ†é…ç›˜å£ç±»å‹
                        var columnDefs = [
                            {name: 'è®©çƒ', min: 300, max: 450},
                            {name: 'å¤§å°', min: 450, max: 580},
                            {name: 'ç‹¬èµ¢', min: 580, max: 720},
                            {name: 'ä¸‹ä¸ªè¿›çƒ', min: 720, max: 850},
                            {name: 'åŒæ–¹çƒé˜Ÿè¿›çƒ', min: 850, max: 980},
                            {name: 'å•åŒ', min: 980, max: 1100},
                            {name: 'é˜Ÿä¼1è¿›çƒ', min: 1100, max: 1220},
                            {name: 'é˜Ÿä¼2è¿›çƒ', min: 1220, max: 1400}
                        ];

                        var processedOdds = rowOdds.map(function(odds) {
                            var betType = 'å…¶ä»–';
                            for (var i = 0; i < columnDefs.length; i++) {
                                if (odds.x >= columnDefs[i].min && odds.x < columnDefs[i].max) {
                                    betType = columnDefs[i].name;
                                    break;
                                }
                            }

                            var handicap = '';
                            for (var j = 0; j < rowHandicaps.length; j++) {
                                if (Math.abs(rowHandicaps[j].x - odds.x) < 120) {
                                    handicap = rowHandicaps[j]. value;
                                    break;
                                }
                            }

                            return {
                                value: odds.value,
                                text: odds.text,
                                betType: betType,
                                handicap: handicap,
                                x: odds.x,
                                y: odds.y
                            };
                        });

                        if (teamName) {
                            if (! currentMatch.team1) {
                                currentMatch.team1 = teamName;
                                currentMatch.team1Score = score;
                                currentMatch.team1Odds = processedOdds;
                            } else if (!currentMatch.team2) {
                                currentMatch.team2 = teamName;
                                currentMatch.team2Score = score;
                                currentMatch.team2Odds = processedOdds;
                            }
                        } else if (processedOdds.length > 0) {
                            if (currentMatch.team1 && ! currentMatch.team2) {
                                currentMatch.team1Odds = currentMatch.team1Odds.concat(processedOdds);
                            } else if (currentMatch.team2) {
                                currentMatch.team2Odds = currentMatch.team2Odds.concat(processedOdds);
                            }
                        }
                    });

                    if (currentMatch && currentMatch.team1) {
                        matches.push(currentMatch);
                    }

                    // ç»Ÿè®¡
                    var totalOdds = 0;
                    matches.forEach(function(m) {
                        totalOdds += (m.team1Odds ?  m.team1Odds.length : 0);
                        totalOdds += (m.team2Odds ?  m.team2Odds.length : 0);
                    });

                    return {
                        matches: matches,
                        total: matches.length,
                        totalOdds: totalOdds,
                        rawElements: allTextData. length,
                        debug: debugInfo,
                        timestamp: new Date().toISOString()
                    };
                }
                return getAllOddsData();
            """)

            if data: 
                self.current_matches = data. get('matches', [])

            return data

        except Exception as e:
            print(f"Error:  {e}")
            return None

    def click_odds_element(self, odds_text, x, y, log_callback):
        try:
            result = self.driver.execute_script(f"""
                var targetValue = '{odds_text}';
                var targetX = {x};
                var targetY = {y};

                var allElements = document.querySelectorAll('*');

                for (var i = 0; i < allElements.length; i++) {{
                    var elem = allElements[i];
                    var text = (elem.innerText || '').trim();

                    if (text === targetValue && elem.offsetWidth > 0 && elem.offsetHeight > 0) {{
                        var rect = elem.getBoundingClientRect();

                        if (Math.abs(rect.x - targetX) < 30 && Math.abs(rect. y - targetY) < 20) {{
                            elem.scrollIntoView({{behavior: 'smooth', block: 'center'}});
                            elem.click();
                            return {{success: true, value: text}};
                        }}
                    }}
                }}

                return {{success: false}};
            """)

            return result

        except Exception as e:
            return {'success': False}

    def place_bet(self, amount, log_callback):
        try:
            time.sleep(1)

            input_result = self.driver.execute_script(f"""
                var amount = {amount};
                var inputs = document.querySelectorAll('input');

                for (var input of inputs) {{
                    var visible = input.offsetWidth > 0 && input. offsetHeight > 0;
                    if (visible && input.type !== 'hidden') {{
                        input.value = '';
                        input.focus();
                        input.value = amount;
                        input.dispatchEvent(new Event('input', {{bubbles: true}}));
                        input.dispatchEvent(new Event('change', {{bubbles: true}}));
                        return {{success: true}};
                    }}
                }}
                return {{success: false}};
            """)

            if not input_result. get('success'):
                log_callback(f"  âš  è¾“å…¥é‡‘é¢å¤±è´¥")
                return False

            log_callback(f"  âœ“ å·²è¾“å…¥é‡‘é¢:  {amount}")
            time.sleep(0.5)

            confirm_result = self.driver.execute_script("""
                var buttons = document.querySelectorAll('button, div, span, a');

                for (var btn of buttons) {
                    var text = (btn.innerText || '').trim();
                    var visible = btn.offsetWidth > 0 && btn.offsetHeight > 0;

                    if (visible && (text === 'ä¸‹æ³¨' || text === 'ç¡®è®¤' || text === 'ç¡®å®š' || text === 'æŠ•æ³¨')) {
                        btn. click();
                        return {success: true, buttonText: text};
                    }
                }
                return {success: false};
            """)

            if confirm_result.get('success'):
                log_callback(f"  âœ“ å·²ç‚¹å‡»:  {confirm_result.get('buttonText')}")
                return True

            return False

        except Exception as e:
            log_callback(f"  âœ— ä¸‹æ³¨å‡ºé”™: {e}")
            return False

    def check_and_auto_bet(self, log_callback):
        if not self.auto_bet_enabled or not self.threshold_settings: 
            return

        for match in self.current_matches:
            match_id = match.get('id')
            team1 = match.get('team1', '')
            team2 = match.get('team2', '')

            for odds in match.get('team1Odds', []):
                bet_type = odds.get('betType', '')
                setting_key = f"{match_id}_{bet_type}_ä¸»"
                threshold = self.threshold_settings.get(setting_key)

                if threshold and odds['value'] >= threshold:
                    bet_key = f"{setting_key}_{odds['text']}_{datetime.now().strftime('%Y%m%d%H%M')}"

                    if bet_key not in self.bet_history:
                        log_callback(f"\nğŸ¯ è§¦å‘è‡ªåŠ¨ä¸‹æ³¨!")
                        log_callback(f"   æ¯”èµ›: {team1} vs {team2}")
                        log_callback(f"   ç›˜å£: {bet_type} {odds. get('handicap', '')}")
                        log_callback(f"   æ–¹å‘: ä¸»é˜Ÿ ({team1})")
                        log_callback(f"   æ°´ä½: {odds['text']} (é˜ˆå€¼: {threshold})")

                        click_result = self.click_odds_element(odds['text'], odds['x'], odds['y'], log_callback)

                        if click_result.get('success'):
                            if self.place_bet(self.bet_amount, log_callback):
                                self.bet_history. append(bet_key)
                                log_callback(f"  âœ“âœ“ ä¸‹æ³¨æˆåŠŸ!  é‡‘é¢: {self.bet_amount} RMB")
                                return True

            for odds in match.get('team2Odds', []):
                bet_type = odds.get('betType', '')
                setting_key = f"{match_id}_{bet_type}_å®¢"
                threshold = self.threshold_settings.get(setting_key)

                if threshold and odds['value'] >= threshold:
                    bet_key = f"{setting_key}_{odds['text']}_{datetime.now().strftime('%Y%m%d%H%M')}"

                    if bet_key not in self.bet_history:
                        log_callback(f"\nğŸ¯ è§¦å‘è‡ªåŠ¨ä¸‹æ³¨!")
                        log_callback(f"   æ¯”èµ›: {team1} vs {team2}")
                        log_callback(f"   ç›˜å£: {bet_type} {odds.get('handicap', '')}")
                        log_callback(f"   æ–¹å‘:  å®¢é˜Ÿ ({team2})")
                        log_callback(f"   æ°´ä½:  {odds['text']} (é˜ˆå€¼: {threshold})")

                        click_result = self. click_odds_element(odds['text'], odds['x'], odds['y'], log_callback)

                        if click_result.get('success'):
                            if self. place_bet(self.bet_amount, log_callback):
                                self.bet_history.append(bet_key)
                                log_callback(f"  âœ“âœ“ ä¸‹æ³¨æˆåŠŸ! é‡‘é¢: {self.bet_amount} RMB")
                                return True

        return False

    def monitor_realtime(self, interval, log_callback, update_callback):
        log_callback(f"\n{'='*50}")
        log_callback(f"ğŸš€ å¼€å§‹å®æ—¶ç›‘æ§æ°´ä½")
        log_callback(f"   åˆ·æ–°é—´éš”: {interval} ç§’")
        log_callback(f"{'='*50}\n")

        while self.is_running:
            try: 
                data = self.get_all_odds_data()

                if data:
                    update_callback(data)

                    if self.auto_bet_enabled: 
                        self.check_and_auto_bet(log_callback)

                time.sleep(interval)

            except Exception as e:
                log_callback(f"âœ— ç›‘æ§é”™è¯¯: {str(e)}")
                time. sleep(interval)

        log_callback("\nç›‘æ§å·²åœæ­¢")

    def stop(self):
        self.is_running = False
        if self.driver:
            try:
                self.driver.quit()
            except:
                pass
# ================== GUI ç±» ==================
class BettingBotGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("æ»šçƒæ°´ä½å®æ—¶ç›‘æ§ç³»ç»Ÿ")
        self.root.geometry("1850x980")
        self.root.configure(bg='#1a1a2e')

        self.bot = BettingBot()
        self.monitor_thread = None
        self. threshold_entries = {}

        self.bet_types = ['è®©çƒ', 'å¤§å°', 'ç‹¬èµ¢', 'ä¸‹ä¸ªè¿›çƒ', 'åŒæ–¹çƒé˜Ÿè¿›çƒ', 'å•åŒ',
                         'é˜Ÿä¼1è¿›çƒ', 'é˜Ÿä¼2è¿›çƒ', 'æ€»åˆ†', 'ç¬¬1é˜Ÿå¾—åˆ†', 'ç¬¬2é˜Ÿå¾—åˆ†',
                         'è®©çƒä¸‹åŠåœº', 'æ€»åˆ†ä¸‹åŠåœº', 'è®©çƒä¸ŠåŠåœº', 'å¤§å°ä¸ŠåŠåœº']

        self.create_widgets()

    def create_widgets(self):
        # æ ‡é¢˜
        title_frame = tk.Frame(self.root, bg='#1a1a2e')
        title_frame.pack(fill='x', padx=20, pady=10)

        tk.Label(title_frame, text="ğŸ¯ æ»šçƒæ°´ä½å®æ—¶ç›‘æ§ç³»ç»Ÿ", bg='#1a1a2e', fg='#00ff88',
                font=('Microsoft YaHei UI', 20, 'bold')).pack()
        tk.Label(title_frame, text="æ”¯æŒTAHOMAå­—ä½“è§£æï¼Œå¯é’ˆå¯¹æ¯åœºæ¯”èµ›ã€æ¯ä¸ªç›˜å£ã€ä¸»é˜Ÿ/å®¢é˜Ÿåˆ†åˆ«è®¾ç½®æ°´ä½é˜ˆå€¼",
                bg='#1a1a2e', fg='#888888', font=('Microsoft YaHei UI', 9)).pack()

        # ä¸»å®¹å™¨
        main_container = tk.Frame(self.root, bg='#1a1a2e')
        main_container.pack(fill='both', expand=True, padx=20, pady=10)

        # å·¦ä¾§æ§åˆ¶é¢æ¿
        left_frame = tk.Frame(main_container, bg='#16213e', width=320)
        left_frame.pack(side='left', fill='y', padx=(0, 10))
        left_frame.pack_propagate(False)

        # ç™»å½•åŒºåŸŸ
        login_frame = tk.LabelFrame(left_frame, text="ğŸ” ç™»å½•", bg='#16213e',
                                   fg='#00ff88', font=('Microsoft YaHei UI', 11, 'bold'),
                                   padx=10, pady=10)
        login_frame.pack(fill='x', padx=10, pady=(10, 5))

        tk.Label(login_frame, text="ç”¨æˆ·å:", bg='#16213e', fg='#ffffff',
                font=('Microsoft YaHei UI', 10)).grid(row=0, column=0, sticky='w', pady=3)
        self.username_entry = tk.Entry(login_frame, bg='#0f3460', fg='#ffffff',
                                      font=('Consolas', 10), insertbackground='#ffffff',
                                      relief='flat', width=20)
        self.username_entry.grid(row=0, column=1, pady=3, padx=(5, 0))
        self.username_entry.insert(0, USERNAME)

        tk.Label(login_frame, text="å¯†ç :", bg='#16213e', fg='#ffffff',
                font=('Microsoft YaHei UI', 10)).grid(row=1, column=0, sticky='w', pady=3)
        self.password_entry = tk.Entry(login_frame, show="*", bg='#0f3460', fg='#ffffff',
                                      font=('Consolas', 10), insertbackground='#ffffff',
                                      relief='flat', width=20)
        self.password_entry. grid(row=1, column=1, pady=3, padx=(5, 0))
        self.password_entry.insert(0, PASSWORD)

        self.login_btn = tk.Button(login_frame, text="ç™»å½•", bg='#00ff88', fg='#000000',
                                  font=('Microsoft YaHei UI', 10, 'bold'), relief='flat',
                                  command=self.login, cursor='hand2', padx=15, pady=3)
        self.login_btn.grid(row=2, column=0, columnspan=2, pady=(8, 0))

        # ä¸‹æ³¨è®¾ç½®
        self.bet_frame = tk.LabelFrame(left_frame, text="ğŸ’° ä¸‹æ³¨è®¾ç½®", bg='#16213e',
                                      fg='#ff9900', font=('Microsoft YaHei UI', 11, 'bold'),
                                      padx=10, pady=10)

        tk.Label(self.bet_frame, text="ä¸‹æ³¨é‡‘é¢:", bg='#16213e', fg='#ffffff',
                font=('Microsoft YaHei UI', 10)).grid(row=0, column=0, sticky='w', pady=3)
        self.amount_entry = tk.Entry(self.bet_frame, bg='#0f3460', fg='#00ff88',
                                    font=('Consolas', 11, 'bold'), insertbackground='#ffffff',
                                    relief='flat', width=8)
        self.amount_entry.grid(row=0, column=1, pady=3, padx=(5, 0))
        self.amount_entry.insert(0, "2")
        tk.Label(self.bet_frame, text="RMB", bg='#16213e', fg='#888888',
                font=('Microsoft YaHei UI', 9)).grid(row=0, column=2, padx=3)

        tk.Label(self.bet_frame, text="åˆ·æ–°é—´éš”:", bg='#16213e', fg='#ffffff',
                font=('Microsoft YaHei UI', 10)).grid(row=1, column=0, sticky='w', pady=3)
        self.interval_entry = tk.Entry(self.bet_frame, bg='#0f3460', fg='#ffffff',
                                      font=('Consolas', 11), insertbackground='#ffffff',
                                      relief='flat', width=8)
        self.interval_entry.grid(row=1, column=1, pady=3, padx=(5, 0))
        self.interval_entry.insert(0, "2")
        tk.Label(self.bet_frame, text="ç§’", bg='#16213e', fg='#888888',
                font=('Microsoft YaHei UI', 9)).grid(row=1, column=2, padx=3)

        self.auto_bet_var = tk.BooleanVar(value=False)
        self.auto_bet_check = tk.Checkbutton(self. bet_frame, text="å¯ç”¨è‡ªåŠ¨ä¸‹æ³¨",
                                            variable=self.auto_bet_var,
                                            bg='#16213e', fg='#ff4444',
                                            selectcolor='#0f3460',
                                            activebackground='#16213e',
                                            font=('Microsoft YaHei UI', 10, 'bold'),
                                            command=self. toggle_auto_bet)
        self.auto_bet_check. grid(row=2, column=0, columnspan=3, pady=(8, 0), sticky='w')

        # æ§åˆ¶æŒ‰é’®
        self.control_frame = tk.Frame(left_frame, bg='#16213e')

        self.start_btn = tk.Button(self.control_frame, text="ğŸš€ å¼€å§‹ç›‘æ§", bg='#0088ff',
                                   fg='#ffffff', font=('Microsoft YaHei UI', 11, 'bold'),
                                   relief='flat', command=self.start_monitoring,
                                   cursor='hand2', pady=8)
        self.start_btn.pack(fill='x', pady=(0, 5))

        self.stop_btn = tk.Button(self.control_frame, text="â¹ åœæ­¢ç›‘æ§", bg='#ff4444',
                                  fg='#ffffff', font=('Microsoft YaHei UI', 11, 'bold'),
                                  relief='flat', command=self. stop_monitoring,
                                  cursor='hand2', pady=8, state='disabled')
        self.stop_btn.pack(fill='x', pady=(0, 5))

        self.refresh_btn = tk.Button(self.control_frame, text="ğŸ”„ åˆ·æ–°æ°´ä½", bg='#666666',
                                    fg='#ffffff', font=('Microsoft YaHei UI', 10),
                                    relief='flat', command=self.refresh_data,
                                    cursor='hand2', pady=6)
        self.refresh_btn.pack(fill='x', pady=(0, 5))

        self.diagnose_btn = tk.Button(self.control_frame, text="ğŸ”¬ æ·±åº¦è¯Šæ–­", bg='#ff6600',
                                     fg='#ffffff', font=('Microsoft YaHei UI', 10, 'bold'),
                                     relief='flat', command=self. diagnose_page,
                                     cursor='hand2', pady=6)
        self.diagnose_btn.pack(fill='x', pady=(0, 5))

        self.save_btn = tk.Button(self.control_frame, text="ğŸ’¾ ä¿å­˜é˜ˆå€¼è®¾ç½®", bg='#9933ff',
                                 fg='#ffffff', font=('Microsoft YaHei UI', 10),
                                 relief='flat', command=self.save_thresholds,
                                 cursor='hand2', pady=6)
        self.save_btn. pack(fill='x')

        # æ—¥å¿—åŒºåŸŸ
        log_frame = tk.LabelFrame(left_frame, text="ğŸ“‹ æ—¥å¿—", bg='#16213e',
                                 fg='#888888', font=('Microsoft YaHei UI', 10, 'bold'),
                                 padx=5, pady=5)
        log_frame.pack(fill='both', expand=True, padx=10, pady=10)

        self.log_text = scrolledtext.ScrolledText(log_frame, bg='#0f3460', fg='#00ff88',
                                                 font=('Consolas', 8), relief='flat',
                                                 height=18, wrap='word')
        self.log_text.pack(fill='both', expand=True)

        # å³ä¾§ - æ°´ä½æ•°æ®åŒºåŸŸ
        right_frame = tk.Frame(main_container, bg='#16213e')
        right_frame.pack(side='right', fill='both', expand=True)

        tk.Label(right_frame, text="ğŸ“Š å®æ—¶æ°´ä½æ•°æ®", bg='#16213e',
                font=('Microsoft YaHei UI', 12, 'bold'), fg='#00ff88').pack(anchor='w', pady=(0, 5))

        self.hint_label = tk.Label(right_frame,
                                  text="è¯·å…ˆç™»å½•\n\nç™»å½•åå°†æ˜¾ç¤ºæ‰€æœ‰æ»šçƒæ¯”èµ›çš„æ°´ä½æ•°æ®\n\nå¦‚æœæ— æ³•è·å–æ•°æ®ï¼Œè¯·ç‚¹å‡»ã€Œæ·±åº¦è¯Šæ–­ã€æŒ‰é’®",
                                  bg='#16213e', fg='#888888',
                                  font=('Microsoft YaHei UI', 11), justify='center')
        self.hint_label.pack(pady=80)

        self.odds_canvas = None
        self.odds_inner_frame = None

        # çŠ¶æ€æ 
        status_frame = tk.Frame(self.root, bg='#0f3460', height=30)
        status_frame.pack(side='bottom', fill='x')

        self.status_label = tk.Label(status_frame, text="çŠ¶æ€: æœªç™»å½•", bg='#0f3460',
                                    fg='#888888', font=('Microsoft YaHei UI', 10),
                                    anchor='w', padx=20)
        self.status_label.pack(side='left', fill='y')

        self.time_label = tk.Label(status_frame, text="", bg='#0f3460',
                                  fg='#00ff88', font=('Microsoft YaHei UI', 10),
                                  anchor='e', padx=20)
        self.time_label.pack(side='right', fill='y')

    def create_odds_display_area(self, parent):
        self.hint_label.pack_forget()

        canvas_frame = tk.Frame(parent, bg='#16213e')
        canvas_frame.pack(fill='both', expand=True)

        self.odds_canvas = tk.Canvas(canvas_frame, bg='#0f3460', highlightthickness=0)
        scrollbar_y = tk.Scrollbar(canvas_frame, orient='vertical', command=self.odds_canvas.yview)
        scrollbar_x = tk.Scrollbar(canvas_frame, orient='horizontal', command=self.odds_canvas.xview)

        self.odds_inner_frame = tk.Frame(self.odds_canvas, bg='#0f3460')

        self.odds_canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)

        scrollbar_y.pack(side='right', fill='y')
        scrollbar_x.pack(side='bottom', fill='x')
        self.odds_canvas.pack(side='left', fill='both', expand=True)

        self.canvas_window = self.odds_canvas.create_window((0, 0), window=self.odds_inner_frame, anchor='nw')

        self.odds_inner_frame.bind('<Configure>', lambda e: self.odds_canvas. configure(scrollregion=self. odds_canvas.bbox('all')))
        self.odds_canvas.bind('<Configure>', lambda e: self.odds_canvas.itemconfig(self.canvas_window, width=e.width))
        self.odds_canvas.bind_all('<MouseWheel>', lambda e: self.odds_canvas. yview_scroll(int(-1*(e.delta/120)), 'units'))

    def format_odds_list(self, odds_list, bet_type):
        filtered = [o for o in odds_list if o.get('betType') == bet_type]
        if not filtered:
            return "--", []

        texts = []
        for o in filtered[: 4]:
            h = o.get('handicap', '')
            if h:
                texts.append(f"{h} {o['text']}")
            else:
                texts.append(o['text'])

        return " | ".join(texts), filtered

    def update_odds_display(self, data):
        def update():
            if not self.odds_inner_frame:
                return

            matches = data.get('matches', [])
            total_odds = data.get('totalOdds', 0)
            raw_elements = data.get('rawElements', 0)
            debug = data.get('debug', {})
            timestamp = datetime.now().strftime('%H:%M:%S')

            self.time_label.config(text=f"æœ€åæ›´æ–°: {timestamp}")

            for widget in self.odds_inner_frame.winfo_children():
                widget.destroy()

            self.threshold_entries = {}

            # è°ƒè¯•ä¿¡æ¯
            debug_text = f"è°ƒè¯•:  æ‰«æ={debug.get('totalScanned', 0)}, TAHOMA={debug.get('tahoma2Elements', 0)}, "
            debug_text += f"åŸå§‹å…ƒç´ ={raw_elements}, æ°´ä½={total_odds}, "
            debug_text += f"dataå±æ€§={debug.get('fromDataAttr', 0)}, ä¼ªå…ƒç´ ={debug.get('fromPseudo', 0)}, "
            debug_text += f"ç§æœ‰Unicode={debug.get('privateUnicode', 0)}"
            tk.Label(self.odds_inner_frame, text=debug_text,
                    bg='#0f3460', fg='#666666', font=('Consolas', 8)).pack(anchor='w', padx=10, pady=2)

            if not matches:
                tk.Label(self.odds_inner_frame,
                        text="æš‚æ— æ¯”èµ›æ•°æ®\n\nå¯èƒ½åŸå› :\n1. é¡µé¢æ•°æ®å°šæœªåŠ è½½\n2. ä½¿ç”¨äº†å­—ä½“æ··æ·†æŠ€æœ¯\n3. è¯·ç‚¹å‡»ã€Œæ·±åº¦è¯Šæ–­ã€æŸ¥çœ‹è¯¦æƒ…\n4. å°è¯•æ»šåŠ¨é¡µé¢åé‡æ–°åˆ·æ–°",
                        bg='#0f3460', fg='#888888', font=('Microsoft YaHei UI', 11)).pack(pady=20)
                return

            tk.Label(self.odds_inner_frame,
                    text=f"å…± {len(matches)} åœºæ¯”èµ›ï¼Œ{total_odds} ä¸ªæ°´ä½",
                    bg='#0f3460', fg='#00ff88', font=('Microsoft YaHei UI', 10, 'bold')).pack(anchor='w', padx=10, pady=5)

            current_league = ''

            for match in matches:
                match_id = match.get('id')
                league = match.get('league', '')
                team1 = match.get('team1', 'æœªçŸ¥')
                team2 = match.get('team2', 'æœªçŸ¥')
                score1 = match.get('team1Score', '')
                score2 = match.get('team2Score', '')
                time_str = match.get('time', '')
                team1_odds = match.get('team1Odds', [])
                team2_odds = match.get('team2Odds', [])

                if league and league != current_league:
                    league_frame = tk.Frame(self.odds_inner_frame, bg='#1a1a2e')
                    league_frame.pack(fill='x', pady=(15, 5), padx=5)

                    tk.Label(league_frame, text=f"ğŸ† {league}", bg='#1a1a2e', fg='#ffaa00',
                            font=('Microsoft YaHei UI', 11, 'bold')).pack(anchor='w')
                    current_league = league

                match_title = f"âš½ {score1} {team1} vs {team2} {score2}"
                if time_str:
                    match_title += f"  ({time_str})"

                match_frame = tk.LabelFrame(self.odds_inner_frame, text=match_title,
                                           bg='#16213e', fg='#00ff88',
                                           font=('Microsoft YaHei UI', 10, 'bold'),
                                           padx=10, pady=8)
                match_frame.pack(fill='x', padx=5, pady=5)

                all_bet_types = set()
                for o in team1_odds: 
                    all_bet_types.add(o.get('betType', ''))
                for o in team2_odds:
                    all_bet_types.add(o.get('betType', ''))

                header_frame = tk.Frame(match_frame, bg='#16213e')
                header_frame. pack(fill='x', pady=(0, 5))

                tk.Label(header_frame, text="ç›˜å£", bg='#16213e', fg='#888888',
                        font=('Microsoft YaHei UI', 9, 'bold'), width=12, anchor='w').pack(side='left')
                tk.Label(header_frame, text=f"{team1} æ°´ä½", bg='#16213e', fg='#888888',
                        font=('Microsoft YaHei UI', 9, 'bold'), width=22, anchor='w').pack(side='left')
                tk.Label(header_frame, text="é˜ˆå€¼", bg='#16213e', fg='#ff9900',
                        font=('Microsoft YaHei UI', 9, 'bold'), width=6).pack(side='left')
                tk.Label(header_frame, text=f"{team2} æ°´ä½", bg='#16213e', fg='#888888',
                        font=('Microsoft YaHei UI', 9, 'bold'), width=22, anchor='w').pack(side='left')
                tk.Label(header_frame, text="é˜ˆå€¼", bg='#16213e', fg='#ff9900',
                        font=('Microsoft YaHei UI', 9, 'bold'), width=6).pack(side='left')

                tk.Frame(match_frame, bg='#333333', height=1).pack(fill='x', pady=3)

                bet_types_to_show = sorted(list(all_bet_types)) if all_bet_types else self.bet_types[: 8]

                for bet_type in bet_types_to_show:
                    if not bet_type or bet_type == 'å…¶ä»–':
                        continue

                    row_frame = tk.Frame(match_frame, bg='#0f3460')
                    row_frame.pack(fill='x', pady=2)

                    tk.Label(row_frame, text=bet_type, bg='#0f3460', fg='#ffffff',
                            font=('Microsoft YaHei UI', 9), width=12, anchor='w').pack(side='left')

                    team1_text, team1_filtered = self.format_odds_list(team1_odds, bet_type)
                    team1_setting_key = f"{match_id}_{bet_type}_ä¸»"
                    team1_threshold = self.bot. threshold_settings. get(team1_setting_key)
                    team1_has_high = team1_threshold and any(o['value'] >= team1_threshold for o in team1_filtered)
                    team1_color = '#ff4444' if team1_has_high else ('#00ff88' if team1_filtered else '#555555')

                    team1_frame = tk.Frame(row_frame, bg='#0f3460', width=170)
                    team1_frame.pack(side='left')
                    team1_frame.pack_propagate(False)
                    tk.Label(team1_frame, text=team1_text, bg='#0f3460', fg=team1_color,
                            font=('Consolas', 9), anchor='w').pack(anchor='w')

                    team1_entry = tk.Entry(row_frame, bg='#1a1a2e', fg='#ffaa00',
                                          font=('Consolas', 10), width=5,
                                          insertbackground='#ffaa00', relief='flat')
                    team1_entry.pack(side='left', padx=3)
                    if team1_threshold:
                        team1_entry.insert(0, str(team1_threshold))
                    self.threshold_entries[team1_setting_key] = team1_entry

                    team2_text, team2_filtered = self.format_odds_list(team2_odds, bet_type)
                    team2_setting_key = f"{match_id}_{bet_type}_å®¢"
                    team2_threshold = self.bot.threshold_settings.get(team2_setting_key)
                    team2_has_high = team2_threshold and any(o['value'] >= team2_threshold for o in team2_filtered)
                    team2_color = '#ff4444' if team2_has_high else ('#00ff88' if team2_filtered else '#555555')

                    team2_frame = tk.Frame(row_frame, bg='#0f3460', width=170)
                    team2_frame.pack(side='left')
                    team2_frame.pack_propagate(False)
                    tk.Label(team2_frame, text=team2_text, bg='#0f3460', fg=team2_color,
                            font=('Consolas', 9), anchor='w').pack(anchor='w')

                    team2_entry = tk.Entry(row_frame, bg='#1a1a2e', fg='#ffaa00',
                                          font=('Consolas', 10), width=5,
                                          insertbackground='#ffaa00', relief='flat')
                    team2_entry.pack(side='left', padx=3)
                    if team2_threshold:
                        team2_entry.insert(0, str(team2_threshold))
                    self.threshold_entries[team2_setting_key] = team2_entry

            self.odds_inner_frame.update_idletasks()
            self.odds_canvas.configure(scrollregion=self.odds_canvas.bbox('all'))

        self.root.after(0, update)

    def log(self, message):
        def update_log():
            timestamp = datetime.now().strftime('%H:%M:%S')
            self.log_text.insert('end', f"[{timestamp}] {message}\n")
            self.log_text.see('end')

        self.root.after(0, update_log)

    def toggle_auto_bet(self):
        if self.auto_bet_var.get():
            if messagebox.askyesno("ç¡®è®¤", "ç¡®å®šå¯ç”¨è‡ªåŠ¨ä¸‹æ³¨å—ï¼Ÿ\n\næ°´ä½è¾¾åˆ°é˜ˆå€¼æ—¶å°†è‡ªåŠ¨ä¸‹æ³¨ï¼"):
                self.bot.auto_bet_enabled = True
                self.log("âš ï¸ è‡ªåŠ¨ä¸‹æ³¨å·²å¯ç”¨ï¼")
            else:
                self.auto_bet_var.set(False)
        else:
            self.bot.auto_bet_enabled = False
            self.log("è‡ªåŠ¨ä¸‹æ³¨å·²å…³é—­")

    def save_thresholds(self):
        count = 0
        for key, entry in self.threshold_entries.items():
            value = entry.get().strip()
            if value: 
                try:
                    threshold = float(value)
                    self.bot.threshold_settings[key] = threshold
                    count += 1
                except ValueError:
                    pass
            else:
                if key in self.bot.threshold_settings:
                    del self.bot.threshold_settings[key]

        self.log(f"âœ“ å·²ä¿å­˜ {count} ä¸ªé˜ˆå€¼è®¾ç½®")
        messagebox.showinfo("ä¿å­˜æˆåŠŸ", f"å·²ä¿å­˜ {count} ä¸ªé˜ˆå€¼è®¾ç½®")

    def login(self):
        username = self.username_entry.get()
        password = self.password_entry.get()

        if not username or not password: 
            messagebox.showerror("é”™è¯¯", "è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ")
            return

        self.login_btn.config(state='disabled', text="ç™»å½•ä¸­...")
        self.status_label.config(text="çŠ¶æ€: æ­£åœ¨ç™»å½•.. .", fg='#ffaa00')

        def login_thread():
            try:
                self.bot.setup_driver(headless=False)
                success = self.bot.login(username, password, self.log)

                def update_ui():
                    if success: 
                        self.status_label. config(text="çŠ¶æ€: å·²ç™»å½•", fg='#00ff88')
                        self.login_btn.config(text="âœ“ å·²ç™»å½•", state='disabled')

                        self.bet_frame.pack(fill='x', padx=10, pady=5)
                        self.control_frame.pack(fill='x', padx=10, pady=10)

                        parent = self.hint_label.master
                        self.create_odds_display_area(parent)

                        self.refresh_data()
                    else:
                        self.status_label.config(text="çŠ¶æ€: ç™»å½•å¤±è´¥", fg='#ff4444')
                        self.login_btn. config(state='normal', text="ç™»å½•")

                self.root.after(0, update_ui)

            except Exception as e:
                self.log(f"ç™»å½•å¼‚å¸¸:  {str(e)}")
                def update_ui():
                    self.status_label.config(text="çŠ¶æ€: ç™»å½•å¤±è´¥", fg='#ff4444')
                    self.login_btn.config(state='normal', text="ç™»å½•")
                self.root.after(0, update_ui)

        threading.Thread(target=login_thread, daemon=True).start()

    def start_monitoring(self):
        try:
            interval = float(self.interval_entry.get())
            amount = float(self.amount_entry.get())
        except ValueError:
            messagebox. showerror("é”™è¯¯", "è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—")
            return

        if interval < 0.5:
            messagebox.showwarning("è­¦å‘Š", "åˆ·æ–°é—´éš”ä¸èƒ½å°äº0.5ç§’")
            return

        self. save_thresholds()

        self.bot.bet_amount = amount
        self.bot. auto_bet_enabled = self.auto_bet_var.get()
        self.bot.is_running = True

        self.start_btn.config(state='disabled')
        self.stop_btn.config(state='normal')
        self.status_label.config(text="çŠ¶æ€: ç›‘æ§ä¸­.. .", fg='#00ff88')

        self.monitor_thread = threading.Thread(
            target=self.bot.monitor_realtime,
            args=(interval, self.log, self.update_odds_display),
            daemon=True
        )
        self.monitor_thread. start()

    def stop_monitoring(self):
        self.bot.is_running = False
        self.start_btn.config(state='normal')
        self.stop_btn.config(state='disabled')
        self.status_label.config(text="çŠ¶æ€: å·²åœæ­¢", fg='#ffaa00')
        self.log("ç›‘æ§å·²åœæ­¢")

    def diagnose_page(self):
        """æ·±åº¦è¯Šæ–­é¡µé¢"""
        if not self.bot.driver:
            messagebox.showerror("é”™è¯¯", "è¯·å…ˆç™»å½•")
            return

        def diagnose_thread():
            self.log("\n" + "="*50)
            self.log("ğŸ”¬ å¼€å§‹æ·±åº¦è¯Šæ–­...")
            self.log("="*50)

            try:
                # ç­‰å¾…æ•°æ®åŠ è½½
                self.bot.wait_for_matches_to_load(self.log)

                # åˆ†æTAHOMAå­—ä½“
                font_result = self.bot.decode_tahoma2_font(self.log)

                # å®šä½æ¯”èµ›å®¹å™¨
                container_result = self.bot.find_match_container(self.log)

                # è·å–æ•°æ®
                self.log("\nğŸ“Š å°è¯•è·å–æ°´ä½æ•°æ®...")
                data = self.bot.get_all_odds_data()

                if data:
                    self.log(f"\nè·å–ç»“æœ:")
                    self.log(f"  æ¯”èµ›æ•°: {data. get('total', 0)}")
                    self.log(f"  æ°´ä½æ•°: {data.get('totalOdds', 0)}")
                    self.log(f"  åŸå§‹å…ƒç´ : {data.get('rawElements', 0)}")

                    debug = data.get('debug', {})
                    self.log(f"  æ‰«æå…ƒç´ : {debug.get('totalScanned', 0)}")
                    self.log(f"  TAHOMAå…ƒç´ : {debug.get('tahoma2Elements', 0)}")
                    self.log(f"  dataå±æ€§: {debug.get('fromDataAttr', 0)}")
                    self.log(f"  ä¼ªå…ƒç´ : {debug.get('fromPseudo', 0)}")
                    self.log(f"  ç§æœ‰Unicode: {debug.get('privateUnicode', 0)}")

                    self.update_odds_display(data)

                self.log("\n" + "="*50)
                self.log("è¯Šæ–­å®Œæˆï¼")
                self.log("="*50)

                # ç»™å‡ºå»ºè®®
                if font_result and font_result.get('count', 0) > 0:
                    samples = font_result.get('samples', [])
                    has_private = any(
                        any(u. get('isPrivate') for u in s. get('unicode', []))
                        for s in samples
                    )
                    if has_private:
                        self.log("\nâš ï¸ å»ºè®®:  æ£€æµ‹åˆ°å­—ä½“æ··æ·†ï¼Œéœ€è¦åˆ†æå­—ä½“æ˜ å°„")
                    else:
                        self.log("\nâœ“ TAHOMAå­—ä½“æœªä½¿ç”¨ç§æœ‰UnicodeåŒºåŸŸ")

                if data and data.get('totalOdds', 0) == 0:
                    self. log("\nğŸ’¡ å»ºè®®:")
                    self.log("  1. å°è¯•æ‰‹åŠ¨æ»šåŠ¨é¡µé¢åé‡æ–°åˆ·æ–°")
                    self. log("  2. æ£€æŸ¥æ˜¯å¦æœ‰æ¯”èµ›æ­£åœ¨è¿›è¡Œ")
                    self.log("  3. ç½‘ç«™å¯èƒ½ä½¿ç”¨äº†Canvasæ¸²æŸ“ï¼Œéœ€è¦OCRæ–¹æ¡ˆ")

            except Exception as e:
                self.log(f"\nè¯Šæ–­å‡ºé”™: {str(e)}")

        threading.Thread(target=diagnose_thread, daemon=True).start()

    def refresh_data(self):
        def refresh_thread():
            self.log("æ­£åœ¨è·å–æ°´ä½æ•°æ®...")

            try:
                # å…ˆç­‰å¾…åŠ è½½
                self.bot.wait_for_matches_to_load(self.log)

                # è·å–æ•°æ®
                data = self.bot.get_all_odds_data()

                if data:
                    total_odds = data.get('totalOdds', 0)
                    raw_elements = data.get('rawElements', 0)
                    debug = data.get('debug', {})

                    self.update_odds_display(data)

                    self.log(f"âœ“ è·å–åˆ° {data.get('total', 0)} åœºæ¯”èµ›ï¼Œ{total_odds} ä¸ªæ°´ä½")
                    self. log(f"  åŸå§‹å…ƒç´ : {raw_elements}")
                    self.log(f"  æ¥æºç»Ÿè®¡: dataå±æ€§={debug.get('fromDataAttr', 0)}, "
                            f"ä¼ªå…ƒç´ ={debug.get('fromPseudo', 0)}, "
                            f"ç›´æ¥æ–‡æœ¬={debug.get('fromText', 0)}, "
                            f"ç§æœ‰Unicode={debug.get('privateUnicode', 0)}")

                    if total_odds == 0:
                        self.log("\nâš ï¸ æœªè·å–åˆ°æ°´ä½æ•°æ®")
                        self.log("  å»ºè®®: ç‚¹å‡»ã€Œæ·±åº¦è¯Šæ–­ã€æŸ¥çœ‹è¯¦ç»†åŸå› ")
                else:
                    self.log("âŒ æœªè·å–åˆ°æ•°æ®")

            except Exception as e:
                self.log(f"åˆ·æ–°å¤±è´¥: {e}")

        threading.Thread(target=refresh_thread, daemon=True).start()

    def on_closing(self):
        if messagebox.askokcancel("é€€å‡º", "ç¡®å®šé€€å‡ºï¼Ÿ"):
            self.bot.stop()
            self.root.destroy()


# ================== ä¸»ç¨‹åº ==================
if __name__ == "__main__":
    root = tk. Tk()
    app = BettingBotGUI(root)
    root.protocol("WM_DELETE_WINDOW", app.on_closing)
    root.mainloop()
